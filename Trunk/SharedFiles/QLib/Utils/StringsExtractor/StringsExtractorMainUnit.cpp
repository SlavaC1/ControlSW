//---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop

#include <cstring>
#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
#include "regex.hpp"
#include "QFile.h"

#pragma argsused


using namespace std;
using namespace boost;

// Collection of strings found so far
map<string,int> gStringsList;

unsigned gLinesCount = 0;
int      gEntries = 0;
bool     gAddFileStrings = false;


TStringList *gStrList = new TStringList;


bool grep_callback(const match_results<string::const_iterator,regex::alloc_type>& what)
{
//  string Str = ExpandStr();

  gAddFileStrings = true;

  // Store the string a the map
  gStringsList[what[0]] = 0;

// Ran's Version
//  gStringsList[what[1]] = 0;
  return true;
}

void LoadFile(string& s,string FileName)
{
	s.reserve(300);

	QOSFileCreator FileCreator;

	try{
		// Open the file for write
		FileCreator.CreateFile(FileName,"rt");
	}
	catch(EQOSFileCreator& Err)
	{
		throw;
	}

	FILE *fp = FileCreator.toSTDIO();

	if(fp == NULL)
	{
		s = "";
		return;
	}

	MutexFilesMap.InsertFileMutex(FileName);//Creating and inserting a mutex for this specific file(if not inserted already)

	//Entering the critical section.
	MutexFilesMap.WaitFor(FileName);

	char c;
	while((c = fgetc(fp)) != EOF)
	{
		if(s.capacity() == s.size())
		  s.reserve(s.capacity() * 3);

		s.append(1,c);
	}

	fclose(fp);
	MutexFilesMap.Release(FileName);
}

// Process a single file
void ProcessFile(string FileName)
{
  map<string,int>::iterator i;
  string FileStr;
  string s;

  // Resetting flag
  gAddFileStrings = false;

  cout << "Processing file: " << FileName.c_str() << endl;

  LoadFile(FileStr,FileName);

  gLinesCount += count(FileStr.begin(),FileStr.end(),'\n');

  if(FileStr != "")
  {
    // Ran's Version
//  regex e("\\bQXlt *\\( *?(.*(\\\\\"\\))*.*?) *\\)");
//  regex e("\\bQXlt *\\( *\"(.+?)\" *\\)");

//    regex e("[\\x20-\\x7F]{0,250}\"[\\x20-\\x7F]{0,250}"); // All the strings in the system
    regex e("throw [\\x20-\\x7F]{0,250}\"[\\x20-\\x7F]{0,250}"); // Only the 'throw' strings ('on screen error messages')

    regex_grep(grep_callback,FileStr,e);

    // If there are any strings to add...
    if(gAddFileStrings == true)
    {
      int FileLength = FileName.length();
      string Asterisk = "";

      for(int i = 0; i < FileLength; i++)
        Asterisk += "*";

      // Add File Name to the string list
      gStrList->Add("");
      gStrList->Add(FileName.c_str());
      gStrList->Add(Asterisk.c_str());

      // Adding the current file's strings
      for(i = gStringsList.begin(); i != gStringsList.end(); ++i)
      {
        s = i->first;

        gStrList->Add(s.c_str());
        gEntries++;
      }
    }

    // Clearing the string list for the next file...
    gStringsList.clear();
  }
}

// Process a single directory
void ProcessDirectory(string DirectoryPath,string mySearchPath)
{
  TSearchRec SearchRec;

  if(FindFirst(mySearchPath.c_str(),faAnyFile,SearchRec) == 0)
    do
    {
      // If it is a sub-diectory, recurse ProcessDirectory
      if(SearchRec.Attr & faDirectory)
      {
        // Ignore the '.' and '..' directories
        if((SearchRec.Name != ".") && (SearchRec.Name != ".."))
        {
          string NewDir = DirectoryPath + "\\" + SearchRec.Name.c_str();
          ProcessDirectory(NewDir,NewDir + "\\*.*");
        }
      } else
        {
          // Extract the file extenstion
          regex e(".+\\.(.*)");
          match_results<string::const_iterator> what;

          string FileName(SearchRec.Name.c_str());
          regex_match(FileName,what,e);

          string FileExt = what[1];

          // Check if it is a 'cpp' file or 'h' file
          if((FileExt == "cpp") | (FileExt == "c") || (FileExt == "h") || (FileExt == "hpp"))
            ProcessFile(DirectoryPath + "\\" + FileName);
        }

    } while(FindNext(SearchRec) == 0);

  FindClose(SearchRec);
}

void GenerateRCFile(AnsiString FileName)
{
  TStringList *StrList = new TStringList;

  StrList->Add("// Automatically generated by StringsExtractor");
  StrList->Add("");
  StrList->Add("STRINGTABLE");
  StrList->Add("{");

  map<string,int>::iterator i;

  int Index = 0;
  string s;

  for(i = gStringsList.begin(); i != gStringsList.end(); ++i)
  {
    s = "  " + string(IntToStr(Index++).c_str()) + ", \"" + i->first + "\"";

    StrList->Add(s.c_str());
  }

  StrList->Add("}");
  StrList->Add("");

  StrList->SaveToFile(FileName);
}


void GenerateHeaderFile(AnsiString FileName)
{
  gStrList->Add("");

  gStrList->Add("Total " + IntToStr(gEntries) + " Strings");

  gStrList->SaveToFile(FileName);
  delete gStrList;
}

int main(int argc, char* argv[])
{
  if(argc != 3)
  {
    cout << "Invalid number of arguments." << endl;
    cout << "Syntax: StringsExtractor BaseDirectory HFileName" << endl;
  } else
    {
      string DirStr;

      // If the last character is '\' remove it from the search string
      if(argv[1][strlen(argv[1]) - 1] == '\\')
        argv[1][strlen(argv[1]) - 1] = NULL;

      DirStr = string(argv[1]);

      gStrList->Add("// Automatically generated by StringsExtractor");
      gStrList->Add("");

      ProcessDirectory(DirStr,DirStr + "\\*.*");

//      GenerateRCFile(argv[2]);
      GenerateHeaderFile(argv[2]);

      cout << "Done Ok. (" << gLinesCount << ") lines processed" << endl;
    }
}

