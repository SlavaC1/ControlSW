/*===========================================================================
 *   FILENAME       : TIMER DRIVER {TimerDrv.C}  
 *   PURPOSE        : Software time handler(timer's ,sysclock ,delay's ...) 
 *   DATE CREATED   : 11/07/2002
 *   PROGRAMMER     : Nir Sade 
 *===========================================================================*/
#include "..\SysDef\c8051f120.h"
#include "..\SysDef\Define.h"
#ifdef OCB_SIMULATOR
#include "..\TimerSim\TimerDrv.h"
#else
#include "..\Timer\TimerDrv.h"
#endif

// Constants
// =========

#define COUNT_10_MS		0xffff - 0x2400

#if defined SIMULATOR  || defined OCB_SIMULATOR
#define TIMER_SIM_RATIO	 1 //7.4
#else
#define TIMER_SIM_RATIO	 1
#endif

// Local variables
// ===============
WORD xdata TimerCounter;	
WORD xdata SecondsTimerCounter;	
WORD xdata OneSecondCounter;	
static  xdata TIMER_struct  TimerStructure;

// Local routines
// ==============
WORD DiffTime(WORD t1,WORD t2);

	

/****************************************************************************
 *
 *  NAME        : Timer_2_Init
 *
 *
 *  DESCRIPTION : Initialization of timer 2.                                        
 *
 ****************************************************************************/
void Timer_2_Init(void)
 {

// Switch to TMR2_PAGE page
    SFRPAGE = TMR2_PAGE;  

// stop the timer
// --------------
	TR2 = 0;

// set as timer
// ------------
	CT2 = 0;

// set auto reload mode
// --------------------
	CPRL2 = 0;

// set the value of RCAP2 for a period of 10ms
// -------------------------------------------
	RCAP2L = COUNT_10_MS & LSB_MASK; 
	RCAP2H = (COUNT_10_MS & MSB_MASK) >> 8;

// select the clock supplied to timer 2 as the system clock divided by 12
// ----------------------------------------------------------------------
	CKCON &= 0xdf; 

// set Timer2 to reload immediately
// --------------------------------
	TMR2L = 0xff;									  
	TMR2H = 0xff;

// disable timer 2 interrupt
// -------------------------
	ET2 = 0;

// start timer 2
// -------------
	TR2 = 1;	

 }


/****************************************************************************
 *
 *  NAME        : Timer_0_Init
 *
 *
 *  DESCRIPTION : Initialization of timer 0.                                        
 *
 ****************************************************************************/
void Timer_0_Init()
{

   SFRPAGE = TIMER01_PAGE;  // Switch to TIMER01_PAGE page

// disable timer 0
// ---------------
	TR0 = 0; // bit in TCON, which is on page TIMER01_PAGE.

// reset the timer counter
// -----------------------
	TimerCounter = 0;
    SecondsTimerCounter = 0;
	OneSecondCounter = 0;

// select timer 0 as a 16 bit timer (mode 1) generated by the system clock
// -----------------------------------------------------------------------
  TMOD |= 0x01;
 
// load the timer registers fot a period of 10ms
// ---------------------------------------------
	TL0 = COUNT_10_MS & LSB_MASK;
	TH0 = (COUNT_10_MS & MSB_MASK) >> 8;

// select the clock supplied to timer  as the system clock divided by 12
// ----------------------------------------------------------------------
	CKCON &= 0xF4;  // Reset bits SCA0 and SCA1 -> System clock divide by 12.
	                // Reset bit T0M -> Use the prescaled clock.

// enable timer 0 interrupt
// -------------------------
	ET0 = 1;
	
// enable timer 0
// --------------
	TR0 = 1;
}


/****************************************************************************
 *
 *  NAME        : Timer_0_ISR
 *
 *
 *  DESCRIPTION : Interrput service routine of timer 0.                                        
 *
 ****************************************************************************/
void Timer_0_ISR (void) interrupt 1 using 1
{
// clear timer 0 overflow flag
// ---------------------------
	TF0 = 0;

// increment the timer counter
// ---------------------------
	TimerCounter++;

    OneSecondCounter++;

    if (OneSecondCounter >= 100) // Another Second has gone by...
	{ 
	  OneSecondCounter = 0;
	  SecondsTimerCounter++;  //(wrap around)
	}

// load the timer registers fot a period of 10ms
// -------------------------
	TL0 = COUNT_10_MS & LSB_MASK;
	TH0 = (COUNT_10_MS & MSB_MASK) >> 8;
}


/****************************************************************************
 *
 *  NAME        : Timer_4_Init
 *
 *
 *  DESCRIPTION : Initialization of timer 4 as a baud rate generator for UART 1                                       
 *
 ****************************************************************************/
void Timer_4_Init()
{

// Switch to TMR4_PAGE page.     
    SFRPAGE = TMR4_PAGE;   

// Disable timer 4
	TMR4CN &= 0xFB;

// Select timer 4 as a a baud rate generator (mode 2) 
  TMR4CN |= 0x30;

// Select timer 4 to be incremented by the system clock
  TMR4CN &= 0xFD;

// Select the clock supplied to timer as the system clock 
	CKCON |= 0x40;  

// Disable timer 4 interrupt
	EIE2 &= 0xFB;

// Load the timer register for 9600 bps baud rate
  RCAP4H = 0xFF;
	RCAP4L = 0xDC;

// Enable timer 4
 	TMR4CN |= 0x04;

}


/****************************************************************************
 *
 *  NAME        : SysClkInit
 *
 *
 *  DESCRIPTION : System external clock source initialization.                                        
 *
 ****************************************************************************/
void SysClkInit(void)
{

   int xdata Delay;                              // delay counter

   SFRPAGE = CONFIG_PAGE;  // Switch to CONFIG_PAGE page, for regs: CLKSEL, OSCXCN, OSCICN and XBR

   OSCXCN = 0x27;                          // start external oscillator with
                                           // 18.432MHz crystal

   for (Delay=0; Delay < 256; Delay++);    // XTLVLD blanking interval (>1ms)
  
   CLKSEL |= 0x01;  // Select the external clock;

   OSCICN &= ~0x80;                        // select external oscillator as SYSCLK
                                           // source and enable missing clock
                                           // detector

// enable the crossbar
// -------------------
   XBR2 |= 0x40;

}


/****************************************************************************
 *
 *  NAME        : TimerDelay
 *
 *
 *  DESCRIPTION :                                         
 *
 ****************************************************************************/
void TimerDelay(WORD Delay)
{     

	xdata TIMER_struct	DelayTimer;      
	TimerSetTimeout(&DelayTimer ,Delay);
	while	(!TimerHasTimeoutExpired(&DelayTimer))	
		{
		} 

	return;
}

/****************************************************************************
 *
 *  NAME        : TimerDelay
 *
 *
 *  DESCRIPTION : Set timer time out                                        
 *
 ****************************************************************************/
void TimerSetTimeout(TIMER_struct* Timer,WORD Timeout)
{
	Timeout/=TIMER_SIM_RATIO; //for simulators 	
	
// save start time(counter) and timeout time
// -----------------------------------------
	Timer->StartTime = Timer0GetTimerCounter();

	Timer->Timeout = Timeout;

	Timer->TimeoutReached = FALSE;
	
	return;
}

void TimerSEC_SetTimeout(TIMER_SEC_struct *Timer,WORD Timeout)
{
	Timeout/=TIMER_SIM_RATIO; //for simulators 	
	
// save start time(counter) and timeout time
// -----------------------------------------
	Timer->StartTime = TimerSEC_0GetTimerCounter();

	Timer->Timeout = Timeout;
	
	Timer->TimeoutReached = FALSE;

	return;
}

void Timer_KillTimer(TIMER_struct *Timer)
{
	Timer->TimeoutReached = TRUE;
	return;
}

void TimerSEC_KillTimer(TIMER_SEC_struct *Timer)
{
	Timer->TimeoutReached = TRUE;
	return;
}

/****************************************************************************
 *
 *  NAME        : TimerTimeoutExpired
 *
 *
 *  DESCRIPTION :                                         
 *
 ****************************************************************************/
BOOL TimerHasTimeoutExpired(TIMER_struct* Timer )
{
	WORD  xdata CurrentTime;

// get the current time
// --------------------
  CurrentTime = Timer0GetTimerCounter();

// check if the timeout has passed
// -------------------------------
	if((DiffTime(Timer->StartTime,CurrentTime) < Timer->Timeout)  &&  (Timer->TimeoutReached == FALSE))
 		return  FALSE;

	Timer->TimeoutReached = TRUE;

	return  TRUE;
}

BOOL TimerSEC_HasTimeoutExpired(TIMER_SEC_struct *Timer)
{
	WORD  xdata CurrentTime;

// get the current time
// --------------------
  CurrentTime = TimerSEC_0GetTimerCounter();

// check if the timeout has passed
// -------------------------------
	if((DiffTime(Timer->StartTime,CurrentTime) < Timer->Timeout)  &&  (Timer->TimeoutReached == FALSE))
		return  FALSE;

	Timer->TimeoutReached = TRUE;

	return  TRUE;
}


/****************************************************************************
 *
 *  NAME        : GetTimerStructPtr
 *
 *
 *  DESCRIPTION : This function return a Ptr to the timer structure                                        
 *
 ****************************************************************************/
TIMER_struct *GetTimerStructPtr(void)
{
  return &TimerStructure;
}



/****************************************************************************
 *
 *  NAME        : Timer0GetTimerCounter
 *
 *
 *  DESCRIPTION : Returns timer 0 counter                                  
 *
 ****************************************************************************/
WORD Timer0GetTimerCounter()
{
	WORD RetVal;

// disable timer 0 interrupt
// -------------------------
	ET0 = 0;

	RetVal = TimerCounter;

// enable timer 0 interrupt
// -------------------------
	ET0 = 1;

	return RetVal;

}

WORD TimerSEC_0GetTimerCounter()
{
	WORD RetVal;

// disable timer 0 interrupt
// -------------------------
	ET0 = 0;

	RetVal = SecondsTimerCounter;

// enable timer 0 interrupt
// -------------------------
	ET0 = 1;

	return RetVal;
}


/****************************************************************************
 *
 *  NAME        : DiffTime
 *
 *
 *  DESCRIPTION : Returns the difference between t2 to t1 
 *								(taking wrap-around in a account)                                  
 *
 ****************************************************************************/
WORD DiffTime(WORD t1,WORD t2)
{
  if(t2 > t1)
    return (t2 - t1);

  return ((0xffff - t1) + t2 + 1);
}
