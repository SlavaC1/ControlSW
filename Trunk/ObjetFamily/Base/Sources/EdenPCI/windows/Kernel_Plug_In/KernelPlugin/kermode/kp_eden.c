/************************************************************************
*  File: kp_eden.c
*
*  Kernel PlugIn driver for accessing EDEN devices.
*  The code accesses hardware using WinDriver's WDC library.
*  Code was generated by DriverWizard v10.40.
*
*  Jungo Confidential. Copyright (c) 2011 Jungo Ltd.  http://www.jungo.com
*************************************************************************/

#include "../../../../wd_lib/include/kpstdlib.h"
#include "../../../../wd_lib/kp_include/wd_kp.h"
#include "../../../../wd_lib/kp_include/utils.h"
#include "../../../../wd_lib/include/wdc_defs.h"
#include "../../../../wd_lib/include/status_strings.h"
#include "c:\WinDriver\samples\shared\pci_regs.h"
#include "c:\WinDriver\samples\shared\bits.h"
#include "../eden_lib.h"

#include "c:\WinDriver\plx\lib\plx_lib.h"
#include "../../../../FIFOPci_defs.h"

#define DEBUG

/*************************************************************
  Functions prototypes
 *************************************************************/
BOOL __cdecl KP_EDEN_Open(KP_OPEN_CALL *kpOpenCall, HANDLE hWD, PVOID pOpenData, PVOID *ppDrvContext);
BOOL __cdecl KP_EDEN_Open_32_64(KP_OPEN_CALL *kpOpenCall, HANDLE hWD, PVOID pOpenData, PVOID *ppDrvContext);
void __cdecl KP_EDEN_Close(PVOID pDrvContext);
void __cdecl KP_EDEN_Call(PVOID pDrvContext, WD_KERNEL_PLUGIN_CALL *kpCall, BOOL fIsKernelMode);
BOOL __cdecl KP_EDEN_IntEnable(PVOID pDrvContext, WD_KERNEL_PLUGIN_CALL *kpCall, PVOID *ppIntContext);
void __cdecl KP_EDEN_IntDisable(PVOID pIntContext);
BOOL __cdecl KP_EDEN_IntAtIrql(PVOID pIntContext, BOOL *pfIsMyInterrupt);
DWORD __cdecl KP_EDEN_IntAtDpc(PVOID pIntContext, DWORD dwCount);
BOOL __cdecl KP_EDEN_IntAtIrqlMSI(PVOID pIntContext, ULONG dwLastMessage, DWORD dwReserved);
DWORD __cdecl KP_EDEN_IntAtDpcMSI(PVOID pIntContext, DWORD dwCount, ULONG dwLastMessage, DWORD dwReserved);
BOOL __cdecl KP_EDEN_Event(PVOID pDrvContext, WD_EVENT *wd_event);
static void KP_EDEN_Err(const CHAR *sFormat, ...);
static void KP_EDEN_Trace(const CHAR *sFormat, ...);

int   KP_EDEN_WriteBufferToFIFO (EDEN_DEV_ADDR_DESC *pDev, unsigned long* bufferPtr, int   NumberOfDwords);
DWORD KP_EDEN_ReadDwordFromMem  (EDEN_DEV_ADDR_DESC *pDev, PLX_ADDR  addrSpace, DWORD dwOffset);
void  KP_EDEN_WriteDwordToMem   (EDEN_DEV_ADDR_DESC *pDev, PLX_ADDR  addrSpace, DWORD dwOffset, DWORD data);

#define PTR32 DWORD

typedef struct {
    DWORD dwNumAddrSpaces; /* Total number of device address spaces */
    PTR32 pAddrDesc;       /* Array of device address spaces information */
	long		    bufferLength;
	KPTR            pNonPagedBuffer;
	DWORD*          pBuffer;
	BOOL            bFIFOStartFlag;
	BYTE            intMsg;
} EDEN_DEV_ADDR_DESC_32B;

/*************************************************************
  Functions implementation
 *************************************************************/
/* KP_Init is called when the Kernel PlugIn driver is loaded.
   This function sets the name of the Kernel PlugIn driver and the driver's
   open callback function(s). */
BOOL __cdecl KP_Init(KP_INIT *kpInit)
{
    /* Verify that the version of the WinDriver Kernel PlugIn library
       is identical to that of the windrvr.h and wd_kp.h files */
    if (WD_VER != kpInit->dwVerWD)
    {
        /* Rebuild your Kernel PlugIn driver project with the compatible
         version of the WinDriver Kernel PlugIn library (e.g., kp_nt1040.lib)
         and windrvr.h and wd_kp.h files */

        return FALSE;
    }

    kpInit->funcOpen = KP_EDEN_Open;
    kpInit->funcOpen_32_64 = KP_EDEN_Open_32_64;
    strcpy (kpInit->cDriverName, KP_EDEN_DRIVER_NAME);

    return TRUE;
}

/* KP_EDEN_Open is called when WD_KernelPlugInOpen() is called from
   the user mode.
   pDrvContext will be passed to rest of the Kernel PlugIn  callback
   functions. */
BOOL __cdecl KP_EDEN_Open(KP_OPEN_CALL *kpOpenCall, HANDLE hWD, PVOID pOpenData,
    PVOID *ppDrvContext)
{
    EDEN_DEV_ADDR_DESC *pDevAddrDesc;
    WDC_ADDR_DESC *pAddrDesc;
    DWORD dwSize;
    DWORD dwStatus;

    /* Initialize the EDEN library */
    dwStatus = EDEN_LibInit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        KP_EDEN_Err("KP_EDEN_Open: Failed to initialize the EDEN library: %s",
            EDEN_GetLastErr());
        return FALSE;
    }

    KP_EDEN_Trace("KP_EDEN_Open entered. EDEN library initialized.\n");

    kpOpenCall->funcClose = KP_EDEN_Close;
    kpOpenCall->funcCall = KP_EDEN_Call;
    kpOpenCall->funcIntEnable = KP_EDEN_IntEnable;
    kpOpenCall->funcIntDisable = KP_EDEN_IntDisable;
    kpOpenCall->funcIntAtIrql = KP_EDEN_IntAtIrql;
    kpOpenCall->funcIntAtDpc = KP_EDEN_IntAtDpc;
    kpOpenCall->funcIntAtIrqlMSI = KP_EDEN_IntAtIrqlMSI;
    kpOpenCall->funcIntAtDpcMSI = KP_EDEN_IntAtDpcMSI;
    kpOpenCall->funcEvent = KP_EDEN_Event;

    /* Create a copy of device information in the driver context */
    dwSize = sizeof(EDEN_DEV_ADDR_DESC);
    pDevAddrDesc = malloc(dwSize);
    if (!pDevAddrDesc)
        goto malloc_error;

    COPY_FROM_USER(pDevAddrDesc, pOpenData, dwSize);

    dwSize = sizeof(WDC_ADDR_DESC) * pDevAddrDesc->dwNumAddrSpaces;
    pAddrDesc = malloc(dwSize);
    if (!pAddrDesc)
        goto malloc_error;

    COPY_FROM_USER(pAddrDesc, pDevAddrDesc->pAddrDesc, dwSize);
    pDevAddrDesc->pAddrDesc = pAddrDesc;

    *ppDrvContext = pDevAddrDesc;

    KP_EDEN_Trace("KP_EDEN_Open: Kernel PlugIn driver opened successfully\n");

    return TRUE;

malloc_error:
    KP_EDEN_Err("KP_EDEN_Open: Failed allocating %ld bytes\n", dwSize);
    if (pDevAddrDesc)
        free(pDevAddrDesc);
    EDEN_LibUninit();
    return FALSE;
}

/* KP_EDEN_Open_32_64 is called when WD_KernelPlugInOpen() is called from a
   32-bit user mode application to open a handle to a 64-bit Kernel PlugIn.
   pDrvContext will be passed to the rest of the Kernel PlugIn callback
   functions. */
BOOL __cdecl KP_EDEN_Open_32_64(KP_OPEN_CALL *kpOpenCall, HANDLE hWD,
    PVOID pOpenData, PVOID *ppDrvContext)
{
    EDEN_DEV_ADDR_DESC *pDevAddrDesc;
    EDEN_DEV_ADDR_DESC_32B devAddrDesc_32;
    WDC_ADDR_DESC *pAddrDesc;
    DWORD dwSize;
    DWORD dwStatus;

    /* Initialize the EDEN library */
    dwStatus = EDEN_LibInit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        KP_EDEN_Err("KP_EDEN_Open_32_64: Failed to initialize the EDEN library: %s",
            EDEN_GetLastErr());
        return FALSE;
    }

    KP_EDEN_Trace("KP_EDEN_Open_32_64 entered. EDEN library initialized.\n");

    kpOpenCall->funcClose = KP_EDEN_Close;
    kpOpenCall->funcCall = KP_EDEN_Call;
    kpOpenCall->funcIntEnable = KP_EDEN_IntEnable;
    kpOpenCall->funcIntDisable = KP_EDEN_IntDisable;
    kpOpenCall->funcIntAtIrql = KP_EDEN_IntAtIrql;
    kpOpenCall->funcIntAtDpc = KP_EDEN_IntAtDpc;
    kpOpenCall->funcIntAtIrqlMSI = KP_EDEN_IntAtIrqlMSI;
    kpOpenCall->funcIntAtDpcMSI = KP_EDEN_IntAtDpcMSI;
    kpOpenCall->funcEvent = KP_EDEN_Event;

    /* Copy device information that sent from a 32-bit user application */
    COPY_FROM_USER(&devAddrDesc_32, pOpenData, sizeof(EDEN_DEV_ADDR_DESC_32B));

    /* Create a copy of the device information in the driver context */
    dwSize = sizeof(EDEN_DEV_ADDR_DESC);
    pDevAddrDesc = malloc(dwSize);
    if (!pDevAddrDesc)
        goto malloc_error;

    /* Copy the 32-bit data to a 64-bit struct */
    pDevAddrDesc->dwNumAddrSpaces = devAddrDesc_32.dwNumAddrSpaces;
    pDevAddrDesc->pAddrDesc = devAddrDesc_32.pAddrDesc;

    dwSize = sizeof(WDC_ADDR_DESC) * pDevAddrDesc->dwNumAddrSpaces;
    pAddrDesc = malloc(dwSize);
    if (!pAddrDesc)
        goto malloc_error;

    COPY_FROM_USER(pAddrDesc, (PVOID)(KPTR)devAddrDesc_32.pAddrDesc, dwSize);
    pDevAddrDesc->pAddrDesc = pAddrDesc;

    *ppDrvContext = pDevAddrDesc;

    KP_EDEN_Trace("KP_EDEN_Open_32_64: Kernel PlugIn driver opened successfully\n");

    return TRUE;

malloc_error:
    KP_EDEN_Err("KP_EDEN_Open_32_64: Failed allocating %ld bytes\n", dwSize);
    if (pDevAddrDesc)
        free(pDevAddrDesc);
    EDEN_LibUninit();
    return FALSE;
}

/* KP_EDEN_Close is called when WD_KernelPlugInClose() is called from
    the user mode */
void __cdecl KP_EDEN_Close(PVOID pDrvContext)
{
    DWORD dwStatus;

    KP_EDEN_Trace("KP_EDEN_Close entered\n");

    /* Uninit the EDEN library */
    dwStatus = EDEN_LibUninit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        KP_EDEN_Err("KP_EDEN_Close: Failed to uninit the EDEN library: %s",
            EDEN_GetLastErr());
    }

    /* Free the memory allocated for the driver context */
    if (pDrvContext)
    {
        if (((EDEN_DEV_ADDR_DESC *)pDrvContext)->pAddrDesc)
            free(((EDEN_DEV_ADDR_DESC *)pDrvContext)->pAddrDesc);
        free(pDrvContext);  
    }
}

/* KP_EDEN_Call is called when WD_KernelPlugInCall() is called from the user mode */
void __cdecl KP_EDEN_Call(PVOID pDrvContext, WD_KERNEL_PLUGIN_CALL *kpCall,
    BOOL fIsKernelMode)
{    
	KP_EDEN_Trace("KP_EDEN_Call entered. Message: 0x%lx\n", kpCall->dwMessage);	

    kpCall->dwResult = KP_EDEN_STATUS_OK;	

    switch (kpCall->dwMessage)
    {
    case KP_EDEN_MSG_VERSION:  /* Get the version of the Kernel PlugIn driver */
        {
            DWORD dwVer = KP_EDEN_DRIVER_VERSION;
            KP_EDEN_VERSION *pUserKPVer = (KP_EDEN_VERSION *)(kpCall->pData);

            COPY_TO_USER_OR_KERNEL(&pUserKPVer->dwVer, &dwVer, sizeof(DWORD), fIsKernelMode);
            COPY_TO_USER_OR_KERNEL(pUserKPVer->cVer, "Kernel plugin for XL 64bit", sizeof("Kernel plugin for XL 64bit") + 1, fIsKernelMode);
            kpCall->dwResult = KP_EDEN_STATUS_OK;
        }
        break ;

	case KP_EDEN_MSG_BUFFER_ADDR:
		{		
			COPY_FROM_USER(&(((EDEN_DEV_ADDR_DESC *)pDrvContext)->pNonPagedBuffer), kpCall->pData, sizeof(KPTR));
			((EDEN_DEV_ADDR_DESC *)pDrvContext)->bufferLength = 0;			

			KP_EDEN_Trace("DEBUG: KP_EDEN_Call: KP_EDEN_MSG_BUFFER_ADDR: pNonPagedBuffer = %016I64X\n", ((EDEN_DEV_ADDR_DESC *)pDrvContext)->pNonPagedBuffer);	
		}
		break;

	case KP_EDEN_MSG_WDC_HANDLE:
		{
			EDEN_DEV_ADDR_DESC* pDev      = (EDEN_DEV_ADDR_DESC *)kpCall->pData;			
			EDEN_DEV_ADDR_DESC* pAddrDesc = ((EDEN_DEV_ADDR_DESC *)pDrvContext)->pAddrDesc;

            COPY_FROM_USER(pDrvContext, pDev, sizeof(EDEN_DEV_ADDR_DESC));
			pDev = (EDEN_DEV_ADDR_DESC *)pDrvContext;
			pDev->pAddrDesc = pAddrDesc; 
		}
		break;

	case KP_EDEN_MSG_BUFFER_LENGTH:
		{
		  if(0 != ((EDEN_DEV_ADDR_DESC *)pDrvContext)->bufferLength)
		  {
			  	kpCall->dwResult   = 0x0010; // KP_STATUS_NOK
		  }
          else
		  {
		      long* pLength = (long*)kpCall->pData;
              COPY_FROM_USER_OR_KERNEL(&(((EDEN_DEV_ADDR_DESC *)pDrvContext)->bufferLength), pLength, sizeof(long), fIsKernelMode);
		      ((EDEN_DEV_ADDR_DESC *)pDrvContext)->bFIFOStartFlag = TRUE;
		      ((EDEN_DEV_ADDR_DESC *)pDrvContext)->pBuffer = (DWORD *)(((EDEN_DEV_ADDR_DESC *)pDrvContext)->pNonPagedBuffer);

			  KP_EDEN_Trace("DEBUG: KP_EDEN_Call: KP_EDEN_MSG_BUFFER_LENGTH: bFIFOStartFlag = %s\n", (((EDEN_DEV_ADDR_DESC *)pDrvContext)->bFIFOStartFlag == TRUE) ? "true" : "false");			  
			  KP_EDEN_Trace("DEBUG: KP_EDEN_Call: KP_EDEN_MSG_BUFFER_LENGTH: pBuffer = %016I64X\n", ((EDEN_DEV_ADDR_DESC *)pDrvContext)->pBuffer);			  
		  }		  
		}
		break;

	case KP_EDEN_MSG_GET_INTERRUPT_MSG:
		{			
			BYTE* message = (BYTE *)kpCall->pData;			
			COPY_TO_USER_OR_KERNEL(message, &(((EDEN_DEV_ADDR_DESC *)pDrvContext)->intMsg), sizeof(BYTE), fIsKernelMode);
		}
		break;

    default:
        kpCall->dwResult = KP_EDEN_STATUS_MSG_NO_IMPL;
    }
    
    /* NOTE: You can modify the messages above and/or add your own
             Kernel PlugIn messages.
             When changing/adding messages, be sure to also update the messages
             definitions in ../eden_lib.h. */
}

/* KP_EDEN_IntEnable is called when WD_IntEnable() is called from the user mode
   with a Kernel PlugIn handle.
   The interrupt context (pIntContext) will be passed to the rest of the
   Kernel PlugIn interrupt functions.
   The function returns TRUE if interrupts are enabled successfully. */
BOOL __cdecl KP_EDEN_IntEnable(PVOID pDrvContext, WD_KERNEL_PLUGIN_CALL *kpCall,
    PVOID *ppIntContext)
{
    KP_EDEN_Trace("KP_EDEN_IntEnable entered\n");
    
    /* You can allocate specific memory for each interrupt in *ppIntContext */
    
    /* In this sample we will set the interrupt context to the driver context,
       which has been set in KP_EDEN_Open to hold the device information. */
    *ppIntContext = pDrvContext;

    /* TODO: You can add code here to write to the device in order
             to physically enable the hardware interrupts */

    return TRUE;
}

/* KP_EDEN_IntDisable is called when WD_IntDisable() is called from the
   user mode with a Kernel PlugIn handle */
void __cdecl KP_EDEN_IntDisable(PVOID pIntContext)
{
    KP_EDEN_Trace("KP_EDEN_IntDisable entered\n");
	/* Free any memory allocated in KP_EDEN_IntEnable() here */
}

/* KP_EDEN_IntAtIrql returns TRUE if deferred interrupt processing (DPC) for
   legacy interrupts is required.
   The function is called at HIGH IRQL - at physical interrupt handler.
   Most library calls are NOT allowed at this level, for example:
   NO   WDC_xxx() or WD_xxx calls, apart from the WDC read/write address or
        register functions, WDC_MultiTransfer(), WD_Transfer(),
        WD_MultiTransfer() or WD_DebugAdd().
   NO   malloc().
   NO   free().
   YES  WDC read/write address or configuration/attribute space functions,
        WDC_MultiTransfer(), WD_Transfer(), WD_MultiTransfer() or
        WD_DebugAdd(), or wrapper functions that call these functions.
   YES  specific kernel OS functions (such as WinDDK functions) that can
        be called from HIGH IRQL. [Note that the use of such functions may
        break the code's portability to other OSs.] */
BOOL __cdecl KP_EDEN_IntAtIrql(PVOID pIntContext, BOOL *pfIsMyInterrupt)
{
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
    EDEN_DEV_ADDR_DESC *pDevAddrDesc = (EDEN_DEV_ADDR_DESC *)pIntContext;
	DWORD		ISR_Register;
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	// Cancel the source of the interrupt
	ISR_Register = KP_EDEN_ReadDwordFromMem(pDevAddrDesc, PLX_ADDR_REG, PCI_INTCTRL);
	KP_EDEN_WriteDwordToMem(pDevAddrDesc, PLX_ADDR_REG, PCI_INTCTRL, ISR_Register &~(BIT8 | BIT10| BIT11));

	// Check the source of the interrupt 
	ISR_Register = KP_EDEN_ReadDwordFromMem(pDevAddrDesc, AD_PCI_BAR2, PCI_LCL_INT_STS_CTR_REG) & 0xFF;

	*pfIsMyInterrupt = (ISR_Register & BIT4)? TRUE : FALSE;
 	if (FALSE == *pfIsMyInterrupt)
	{
	    KP_EDEN_WriteDwordToMem(pDevAddrDesc, PLX_ADDR_REG, PCI_INTCTRL, ISR_Register |(BIT8|BIT10|BIT11));
	}
    KP_EDEN_Trace("KP_EDEN_IntAtIrql done\n");
	return *pfIsMyInterrupt;	
}

/* KP_EDEN_IntAtDpc is a Deferred Procedure Call for additional legacy
   interrupt processing. This function is called if KP_EDEN_IntAtIrql returned
   TRUE. KP_EDEN_IntAtDpc returns the number of times to notify the user mode of
   the interrupt (i.e. return from WD_IntWait) */
DWORD __cdecl KP_EDEN_IntAtDpc(PVOID pIntContext, DWORD dwCount)
{   
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	int     	        NoOfWrDwords = 0;
	int                 MaxWriteData = 0;
	unsigned long       Value        = 0;
	EDEN_DEV_ADDR_DESC *pDevAddrDesc = (EDEN_DEV_ADDR_DESC *)pIntContext;
    EDEN_DEV_ADDR_DESC *pKPDev       = (EDEN_DEV_ADDR_DESC *)pIntContext;	
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	KP_EDEN_Trace("DEBUG: KP_EDEN_IntAtDpc: pKPDev->bufferLength = %d\n", pKPDev->bufferLength);	
	KP_EDEN_Trace("DEBUG: KP_EDEN_IntAtDpc: bFIFOStartFlag = %s\n", (pKPDev->bFIFOStartFlag == TRUE) ? "true" : "false");	

	/* If we already started */
	if(FALSE == pKPDev->bFIFOStartFlag)
	{
		/* The FIFO should not be empty in this point */
		if(KP_EDEN_ReadDwordFromMem(pDevAddrDesc, AD_PCI_BAR2, FIFO_STS_REG) == FIFO_EMPTY)
		{
            KP_EDEN_Err("Interrupt at DPC - underrun error\n");

			/* Disable the FIFO interrupt */
			Value = KP_EDEN_ReadDwordFromMem(pDevAddrDesc, AD_PCI_BAR2, PCI_LCL_INT_CTR_REG);
			KP_EDEN_WriteDwordToMem(pDevAddrDesc, PLX_ADDR_SPACE0, PCI_LCL_INT_CTR_REG, Value &~BIT4);
			pKPDev->intMsg = 100; //EDEN_PCI_FIFO_UNDERRUN_ERROR
			return 1;
		}
	}

	if(pKPDev->bufferLength <= 0)
	{
		/* Disable the FIFO interrupt */
		Value = KP_EDEN_ReadDwordFromMem(pDevAddrDesc, AD_PCI_BAR2, PCI_LCL_INT_CTR_REG);
		KP_EDEN_WriteDwordToMem(pDevAddrDesc, PLX_ADDR_SPACE0, PCI_LCL_INT_CTR_REG, Value &~BIT4);

		/* Activate the PCI interrupt */
		Value = KP_EDEN_ReadDwordFromMem(pDevAddrDesc, PLX_ADDR_REG, PCI_INTCTRL);
		KP_EDEN_WriteDwordToMem(pDevAddrDesc, PLX_ADDR_REG, PCI_INTCTRL, Value | (BIT8 | BIT10 | BIT11));
		return 0;
	}

	MaxWriteData = (TRUE == pKPDev->bFIFOStartFlag) ? (MAX_FIFO_SIZE - 10) : MAX_FIFO_AVAIL;
	NoOfWrDwords = KP_EDEN_WriteBufferToFIFO(pDevAddrDesc, pKPDev->pBuffer, MIN(MaxWriteData, pKPDev->bufferLength));

	pKPDev->pBuffer      += NoOfWrDwords;
	pKPDev->bufferLength -= NoOfWrDwords;

	if(TRUE == pKPDev->bFIFOStartFlag) 
	{
		pKPDev->bFIFOStartFlag = FALSE;
		pKPDev->intMsg = 101; //EDEN_PCI_FIFO_START_MESSAGE
		return 1;
	}

	if(pKPDev->bufferLength <= 0)
	{
		/* Disable the FIFO interrupt */
		Value = KP_EDEN_ReadDwordFromMem(pDevAddrDesc, AD_PCI_BAR2, PCI_LCL_INT_CTR_REG);
		KP_EDEN_WriteDwordToMem(pDevAddrDesc, AD_PCI_BAR2, PCI_LCL_INT_CTR_REG, Value &~BIT4);
	}

	/* Activate the PCI interrupt */
	Value = KP_EDEN_ReadDwordFromMem(pDevAddrDesc, PLX_ADDR_REG, PCI_INTCTRL);
	KP_EDEN_WriteDwordToMem(pDevAddrDesc, PLX_ADDR_REG, PCI_INTCTRL, Value | (BIT8 | BIT10 | BIT11));

	return 0;
}

/* KP_EDEN_IntAtIrqlMSI returns TRUE if deferred interrupt processing (DPC) for
   Message-Signaled Interrupts (MSI) or Extended Message-Signaled Interrupts
   (MSI-X) processing is required.
   The function is called at HIGH IRQL - at physical interrupt handler.
   Note: Do not use the dwReserved parameter.
   Most library calls are NOT allowed at this level, for example:
   NO   WDC_xxx() or WD_xxx calls, apart from the WDC read/write address or
        register functions, WDC_MultiTransfer(), WD_Transfer(),
        WD_MultiTransfer() or WD_DebugAdd().
   NO   malloc().
   NO   free().
   YES  WDC read/write address or configuration/attribute space functions,
        WDC_MultiTransfer(), WD_Transfer(), WD_MultiTransfer() or
        WD_DebugAdd(), or wrapper functions that call these functions.
   YES  specific kernel OS functions (such as WinDDK functions) that can
        be called from HIGH IRQL. [Note that the use of such functions may
        break the code's portability to other OSs.] */
BOOL __cdecl KP_EDEN_IntAtIrqlMSI(PVOID pIntContext, ULONG dwLastMessage,
    DWORD dwReserved)
{
    static DWORD dwIntCount = 0; /* Interrupts count */

    /* There is no need to acknowledge MSI/MSI-X. However, you can implement
     the same functionality here as done in the KP_EDEN_IntAtIrql handler
     to read/write data from/to registers at HIGH IRQL. */

    /* This sample schedules a DPC once in every 5 interrupts.
       TODO: You can modify the implementation to schedule the DPC as needed. */
    dwIntCount++;
    if (!(dwIntCount % 5))
        return TRUE;

    return FALSE;
}

/* KP_EDEN_IntAtDpcMSI is a Deferred Procedure Call for additional
   Message-Signaled Interrupts (MSI) or Extended Message-Signaled Interrupts
  (MSI-X) processing.
  This function is called if KP_EDEN_IntAtIrqlMSI returned TRUE.
  KP_EDEN_IntAtDpcMSI returns the number of times to notify the user mode
  of the interrupt (i.e. return from WD_IntWait). */
DWORD __cdecl KP_EDEN_IntAtDpcMSI(PVOID pIntContext, DWORD dwCount,
    ULONG dwLastMessage, DWORD dwReserved)
{
    return dwCount;
}

/* KP_EDEN_Event is called when a Plug-and-Play/power management event for
   the device is received, if EventRegister() was first called from the
   user mode with the Kernel PlugIn handle. */
BOOL __cdecl KP_EDEN_Event(PVOID pDrvContext, WD_EVENT *wd_event)
{
    return TRUE; /* Return TRUE to notify the user mode of the event */
}

/* -----------------------------------------------
    Debugging and error handling
   ----------------------------------------------- */
static void KP_EDEN_Err(const CHAR *sFormat, ...)
{
#if defined(DEBUG)
    CHAR sMsg[256];
    va_list argp;
    va_start(argp, sFormat);
    vsnprintf(sMsg, sizeof(sMsg) - 1, sFormat, argp);
    WDC_Err("%s: %s", KP_EDEN_DRIVER_NAME, sMsg);
    va_end(argp);
#endif
}

static void KP_EDEN_Trace(const CHAR *sFormat, ...)
{
#if defined(DEBUG)
    CHAR sMsg[256];
    va_list argp;
    va_start(argp, sFormat);
    vsnprintf(sMsg, sizeof(sMsg) - 1, sFormat, argp);
    WDC_Trace("%s: %s", KP_EDEN_DRIVER_NAME, sMsg);
    va_end(argp);
#endif
}

DWORD KP_EDEN_ReadDwordFromMem(EDEN_DEV_ADDR_DESC *pDev, PLX_ADDR addrSpace, DWORD dwOffset)
{
	/*~~~~~~~~~~~~~~*/
	WD_TRANSFER    Trans;
    WDC_ADDR_DESC* pAddrDesc;
	/*~~~~~~~~~~~~~~*/
    
	BZERO(Trans);

	pAddrDesc = &pDev->pAddrDesc[addrSpace];
	Trans.dwPort = pAddrDesc->kptAddr + dwOffset;
	Trans.cmdTrans = RM_DWORD;
	WD_Transfer(WDC_GetWDHandle(), &Trans);

	return Trans.Data.Dword;
}


void KP_EDEN_WriteDwordToMem(EDEN_DEV_ADDR_DESC *pDev, PLX_ADDR addrSpace, DWORD dwOffset, DWORD data)
{	
	/* ~~~~~~~~~~~~~~ */
	WD_TRANSFER    Trans;
    WDC_ADDR_DESC* pAddrDesc;

	/* ~~~~~~~~~~~~~~ */
	BZERO(Trans);

    pAddrDesc        = &pDev->pAddrDesc[addrSpace];
	Trans.dwPort     = pAddrDesc->kptAddr + dwOffset;
    Trans.cmdTrans   = WM_DWORD;
	Trans.Data.Dword = data;
	
	if(WD_STATUS_SUCCESS != WD_Transfer(WDC_GetWDHandle(), &Trans))	
		KP_EDEN_Err("DEBUG: WD_Transfer failed");	
}

int KP_EDEN_WriteBufferToFIFO(EDEN_DEV_ADDR_DESC *pDev, DWORD *bufferPtr, int NumberOfDwords)
{
	WD_SLEEP Sleep_struc;
	
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	int				i = 0;
	/* WS */
	unsigned long	Value = KP_EDEN_ReadDwordFromMem(pDev, PLX_ADDR_REG, PLX_M_LBRD0);
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    KP_EDEN_Trace("KP_EDEN_WriteBufferToFIFO- kernel handle: 0x%lx \n", (HANDLE)(WDC_GET_KP_HANDLE(pDev)));
	KP_EDEN_WriteDwordToMem(pDev, PLX_ADDR_REG, PLX_M_LBRD0, Value & 0xFFFFFFC3);	
	
	KP_EDEN_Trace("DEBUG: KP_EDEN_WriteBufferToFIFO: NumberOfDwords = %d\n", NumberOfDwords);	

	KP_EDEN_Trace("DEBUG: bufferPtr = %016I64X\n", bufferPtr);	

	KP_EDEN_Trace("DEBUG: bufferPtr[0] = %d\n", bufferPtr[0]);	
	KP_EDEN_Trace("DEBUG: bufferPtr[1] = %d\n", bufferPtr[1]);
	KP_EDEN_Trace("DEBUG: bufferPtr[2] = %d\n", bufferPtr[2]);	
	KP_EDEN_Trace("DEBUG: bufferPtr[3] = %d\n", bufferPtr[3]);

	for(i = 0; i < NumberOfDwords; i++)
	{
		KP_EDEN_WriteDwordToMem(pDev, AD_PCI_BAR2, FIFO_WRITE_REG, *bufferPtr);
		bufferPtr++;
	}

    KP_EDEN_Trace("KP_EDEN_WriteBufferToFIFO done 0x%lx from 0x%lx dwords\n", i, NumberOfDwords);
    KP_EDEN_Trace("KP_EDEN_WriteBufferToFIFO going to sleep\n");

	Sleep_struc.dwMicroSeconds = 1000;
	WD_Sleep((HANDLE)(WDC_GET_KP_HANDLE(pDev)), &Sleep_struc);

	/* Return the WS back */
	//KP_EDEN_WriteDwordToMem(pDev, PLX_ADDR_REG, PLX_M_LBRD0, 0x40030123);

	return i;
}

