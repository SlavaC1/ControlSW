C51 COMPILER V9.52.0.0   UARTDRV                                                           04/28/2015 17:26:01 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE UARTDRV
OBJECT MODULE PLACED IN .\Temp\UartDrv.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Uart\UartDrv.c LARGE OPTIMIZE(0,SPEED) BROWSE INCDIR(..\SharedModules\SysDe
                    -f,SPI\,..\SharedModules\RingBuffer,UART\,A2D\,..\SharedModules\Xilinx,..\SharedModules\EdenProtocol,Timer\,Potentiometer
                    -\,HeaterControl\,E2PROM\,MsgDecode\,..\SharedModules\Utilities,..\SharedModules\Scheduler,..\SharedModules\Roller,Potent
                    -iometer\,PrintDriver\,Sensors\,HeadData\,Utils\,Watchdog\,Version\,Actuators\,D2A\,Comparator\,Bumper\) DEFINE(C8051F123
                    -_CPU) DEBUG OBJECTEXTEND PRINT(.\Temp\UartDrv.lst) TABS(2) OBJECT(.\Temp\UartDrv.obj)

line level    source

   1          /*===========================================================================
   2           *   FILENAME       : Uart driver {UartDrv.c}  
   3           *   PURPOSE        : Driver to the internal uart of the processor  
   4           *   DATE CREATED   : 11/Nov/2001
   5           *   PROGRAMMER     : Nir Saadon 
   6           *   PROCEDURES     : 
   7           *===========================================================================*/
   8          
   9          #include "c8051F120.h"
  10          #include "Uartdrv.h"
  11          #include "RingBuff.h"
  12          #include "TimerDrv.h"
  13          
  14          #define UART_TX_BUFFER_SIZE 100
  15          
  16          bit UartTxBusy;
  17          BYTE xdata UartTxBuffer[UART_TX_BUFFER_SIZE];  
  18          BYTE xdata UartTxBufferHead;
  19          BYTE xdata UartTxBufferTail;
  20          BYTE xdata UartTxBufferFreeSpace;
  21          RBUF_RingBuffer xdata RcvRingBuffer;
  22          
  23          
  24          /****************************************************************************
  25           *
  26           *  NAME        : Uart0Init
  27           *
  28           *  INPUT       : None
  29           *
  30           *  OUTPUT      : None.
  31           *
  32           *  DESCRIPTION : Initialization of UART 0.                                        
  33           *
  34           ****************************************************************************/
  35          
  36          void Uart0Init(void)
  37          {
  38   1        bit SaveEnableAll = EA;
  39   1        
  40   1        EA = DISABLE;  // Disable Interrupts
  41   1        
  42   1        SFRPAGE = UART0_PAGE;
  43   1        SSTA0 |= 0x10;     // Do not devide baud rate by two.  
  44   1        SSTA0 |= 0x0F;     // Set Timer 4 Overflow to generate UART0 RX & TX baud rates
  45   1        SCON0  = 0x50;     // SCON0.Bits7–6:  Mode 1: 8-Bit UART, Variable Baud Rate
  46   1                   // SCON0.Bit4:     REN0: Receive Enable
  47   1        
  48   1        Timer_4_Init();    // Initialize timer 4 for the baud rate clock
  49   1        
  50   1        TI0 = CLEAR;           // TI:   (SCOND0.Bit1) set TI to send first char of UART
  51   1        RI0 = CLEAR;           // RI:   (SCOND0.Bit0) clear the receive interrupt
C51 COMPILER V9.52.0.0   UARTDRV                                                           04/28/2015 17:26:01 PAGE 2   

  52   1        ES0 = SET;             // Enable serial interrupt
  53   1        PS  = SET;             // interrupt priority to the serial port
  54   1        EA  = SaveEnableAll;    
  55   1        
  56   1        UartTxBusy = FALSE;
  57   1        UartTxBufferHead = 0;
  58   1        UartTxBufferTail = 0;
  59   1        UartTxBufferFreeSpace = UART_TX_BUFFER_SIZE - 1; 
  60   1      }
  61          
  62           /****************************************************************************
  63           *
  64           *  NAME        : Uart0Isr
  65           *
  66           *  INPUT       : None
  67           *
  68           *  OUTPUT      : None.
  69           *
  70           *  DESCRIPTION : The UART Interrupt Service Routine.                                        
  71           *
  72           ****************************************************************************/
  73          void Uart0Isr() interrupt 4 using 2
  74          { 
  75   1        // Disable UART interrupts
  76   1        ES0 = DISABLE;
  77   1        
  78   1        // NOTE: SFRPAGE register will automatically be switched to the Uart0Isr Page When an interrupt occurs.  
             -SFRPAGE will return to its previous setting on exit from this routine.  
  79   1        
  80   1        // Check if a frame error occured 
  81   1        if (SSTA0 & 0x80) // FE0 flag
  82   1          SSTA0 &= ~0x80;
  83   1        
  84   1        // Check if a receive overrun error occured 
  85   1        if (SSTA0 & 0x40) // RXOV0 flag
  86   1          SSTA0 &= ~0x40; 
  87   1        
  88   1        if(RI0)                                                    
  89   1        {
  90   2          RI0 = 0;
  91   2          RingBuffInsert(&RcvRingBuffer); 
  92   2        } 
  93   1        
  94   1        if(TI0)
  95   1        {
  96   2          TI0 = 0;
  97   2          if (UartTxBufferHead != UartTxBufferTail)
  98   2          {
  99   3            SBUF0 = UartTxBuffer[UartTxBufferTail];
 100   3            UartTxBufferTail = (UartTxBufferTail+1) % UART_TX_BUFFER_SIZE;
 101   3            UartTxBufferFreeSpace++;
 102   3          }
 103   2          else
 104   2            UartTxBusy = FALSE; 
 105   2        } 
 106   1        
 107   1        // Enable UART interrupts 
 108   1        ES0 = ENABLE;
 109   1      }
 110          
 111          
 112           /****************************************************************************
C51 COMPILER V9.52.0.0   UARTDRV                                                           04/28/2015 17:26:01 PAGE 3   

 113           *
 114           *  NAME        : Uart1Isr
 115           *
 116           *  DESCRIPTION : UART 1 Interrupt Service Routine.                                        
 117           *
 118           ****************************************************************************/
 119          void Uart1Isr() interrupt 20 using 2
 120          {
 121   1      }
 122          
 123          /****************************************************************************
 124           *
 125           *  NAME        : UartSend
 126           *
 127           *  INPUT       : Data buffer, data length.
 128           *
 129           *  OUTPUT      : UART_STATUS.
 130           *
 131           *  DESCRIPTION : send a data buffer using the UART.                                        
 132           *
 133           ****************************************************************************/
 134          UART_STATUS UartSend(BYTE *Data, BYTE Length)
 135          {
 136   1        BYTE xdata i;
 137   1        bit PrevIntStatus; 
 138   1       
 139   1      // check if there is enough room in the transmit buffer
 140   1      // ----------------------------------------------------
 141   1        if (UartTxBufferFreeSpace < Length)
 142   1        {
 143   2          return UART_TX_BUFFER_FULL;
 144   2        }
 145   1      
 146   1        PrevIntStatus = ES0;
 147   1        ES0 = DISABLE;
 148   1      
 149   1      // copy the data buffer to the Tx buffer
 150   1      // -------------------------------------
 151   1        for (i = 0; i < Length; i++)
 152   1        {
 153   2          UartTxBuffer[UartTxBufferHead] = Data[i];
 154   2          // incerement the head index
 155   2          // -------------------------
 156   2            UartTxBufferHead = (UartTxBufferHead + 1) % UART_TX_BUFFER_SIZE;
 157   2        }
 158   1      
 159   1      // update the free buffer space 
 160   1      // ----------------------------
 161   1        UartTxBufferFreeSpace -= Length;
 162   1       
 163   1      
 164   1      // if the uart is free transmit the first byte - initiate an interrupt
 165   1      // -------------------------------------------------------------------
 166   1        if (!UartTxBusy)
 167   1        {
 168   2          UartTxBusy = TRUE;
 169   2          SBUF0 = UartTxBuffer[UartTxBufferTail];
 170   2          UartTxBufferTail = (UartTxBufferTail+1) % UART_TX_BUFFER_SIZE;
 171   2          UartTxBufferFreeSpace++;
 172   2          }
 173   1      
 174   1        ES0 = PrevIntStatus;
C51 COMPILER V9.52.0.0   UARTDRV                                                           04/28/2015 17:26:01 PAGE 4   

 175   1          return UART_NO_ERROR;
 176   1      }
 177          
 178          
 179          /****************************************************************************
 180           *
 181           *  NAME        : UartGetReceiveBuffer
 182           *
 183           *  INPUT       : None.
 184           *
 185           *  OUTPUT      : RBUF_RingBuffer.
 186           *
 187           *  DESCRIPTION : Returns a pointer to the receive data buffer.                                        
 188           *
 189           ****************************************************************************/
 190          RBUF_RingBuffer *UartGetReceiveBuffer(void)
 191          {
 192   1        return &RcvRingBuffer;
 193   1      }
 194          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    419    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    181    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
