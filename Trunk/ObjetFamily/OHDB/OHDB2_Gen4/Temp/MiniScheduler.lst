C51 COMPILER V9.52.0.0   MINISCHEDULER                                                     04/28/2015 17:26:00 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MINISCHEDULER
OBJECT MODULE PLACED IN .\Temp\MiniScheduler.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\SharedModules\Scheduler\MiniScheduler.c LARGE OPTIMIZE(0,SPEED) BROWSE I
                    -NCDIR(..\SharedModules\SysDef,SPI\,..\SharedModules\RingBuffer,UART\,A2D\,..\SharedModules\Xilinx,..\SharedModules\EdenP
                    -rotocol,Timer\,Potentiometer\,HeaterControl\,E2PROM\,MsgDecode\,..\SharedModules\Utilities,..\SharedModules\Scheduler,..
                    -\SharedModules\Roller,Potentiometer\,PrintDriver\,Sensors\,HeadData\,Utils\,Watchdog\,Version\,Actuators\,D2A\,Comparato
                    -r\,Bumper\) DEFINE(C8051F123_CPU) DEBUG OBJECTEXTEND PRINT(.\Temp\MiniScheduler.lst) TABS(2) OBJECT(.\Temp\MiniScheduler
                    -.obj)

line level    source

   1          /*===========================================================================
   2           *   FILENAME       : Mini Scheduler {MiniScheduler.c}  
   3           *   PURPOSE        : Scheduler  
   4           *   DATE CREATED   : 16/Dec/2001
   5           *   PROGRAMMER     : Nir Saadon 
   6           *===========================================================================*/
   7          
   8          #include "MiniScheduler.h"
   9          #include "TimerDrv.h"
  10          
  11          
  12          // Constants
  13          // =========
  14          #if (defined C8051F023_CPU || defined C8051F123_CPU)
  15            #define MAX_NUM_OF_TASKS 58
  16          #else 
                #define MAX_NUM_OF_TASKS 42
              #endif
  19          
  20          
  21          // Type definitions
  22          // ================
  23          typedef struct {    
  24              TTaskPtr TaskPtr;
  25              BYTE Argument;
  26              TTaskState State;
  27              TIMER_struct Timer;
  28            }TTaskConrolBlock;
  29          
  30          
  31          // Local routines
  32          // ==============
  33          
  34          
  35          // Module variables
  36          // ================
  37          TTaskConrolBlock xdata Tasks[MAX_NUM_OF_TASKS];
  38          BYTE xdata NumOfTasks;
  39          BYTE xdata RunningTask;
  40          
  41          
  42          // Exported routines
  43          // =================
  44          
  45          
  46          
  47          
  48          /****************************************************************************
  49           *
  50           *  NAME        : SchedulerInit
C51 COMPILER V9.52.0.0   MINISCHEDULER                                                     04/28/2015 17:26:00 PAGE 2   

  51           *
  52           *
  53           *  DESCRIPTION : Initialization of the mini scheduler.                                       
  54           *
  55           ****************************************************************************/
  56          void SchedulerInit()
  57          {
  58   1        NumOfTasks = 0;
  59   1        RunningTask = -1;
  60   1      }
  61          
  62          
  63          /****************************************************************************
  64           *
  65           *  NAME        : SchedulerInstallTask
  66           *
  67           *
  68           *  DESCRIPTION : Add a new task to be scheduled and reteurn its handle                                   
             -  
  69           *
  70           ****************************************************************************/
  71          TTaskHandle SchedulerInstallTask(TTaskPtr TaskFunctionPtr)
  72          {
  73   1        TTaskHandle xdata Handle;
  74   1      
  75   1        if (NumOfTasks >= MAX_NUM_OF_TASKS)
  76   1            return -1;
  77   1      
  78   1        Handle = NumOfTasks; 
  79   1        Tasks[Handle].TaskPtr = TaskFunctionPtr;
  80   1        Tasks[Handle].State = TASK_SUSPENDED;
  81   1        
  82   1        NumOfTasks++;
  83   1        
  84   1        return Handle;
  85   1      
  86   1      }
  87          
  88          
  89          /****************************************************************************
  90           *
  91           *  NAME        : SchedulerResumeTask
  92           *
  93           *
  94           *  DESCRIPTION : Resume a task                                      
  95           *
  96           ****************************************************************************/
  97          void SchedulerResumeTask(TTaskHandle Handle,BYTE Arg)
  98          {
  99   1        Tasks[Handle].State = TASK_RESUMED;
 100   1        Tasks[Handle].Argument = Arg;
 101   1      }
 102          
 103          
 104          /****************************************************************************
 105           *
 106           *  NAME        : SchedulerSuspendTask
 107           *
 108           *
 109           *  DESCRIPTION : Suspend a task                                      
 110           *
 111           ****************************************************************************/
C51 COMPILER V9.52.0.0   MINISCHEDULER                                                     04/28/2015 17:26:00 PAGE 3   

 112          void SchedulerSuspendTask(TTaskHandle Handle)
 113          {
 114   1      // if a task suspended it self
 115   1      // ---------------------------
 116   1        if (Handle == -1)
 117   1          Tasks[RunningTask].State = TASK_SUSPENDED;
 118   1        else
 119   1          Tasks[Handle].State = TASK_SUSPENDED;
 120   1      }
 121          
 122          
 123          /****************************************************************************
 124           *
 125           *  NAME        : SchedulerLeaveTask
 126           *
 127           *
 128           *  DESCRIPTION : Leave a task                                      
 129           *
 130           ****************************************************************************/
 131          void SchedulerLeaveTask(BYTE Arg)
 132          {
 133   1        Tasks[RunningTask].Argument = Arg;
 134   1        Tasks[RunningTask].State = TASK_RESUMED;
 135   1      }
 136          
 137          
 138          /****************************************************************************
 139           *
 140           *  NAME        : SchedulerTaskSleep
 141           *
 142           *
 143           *  DESCRIPTION : Send a task to sleep                                      
 144           *
 145           ****************************************************************************/
 146          void SchedulerTaskSleep(TTaskHandle Handle, WORD SleepTime)
 147          { 
 148   1      // if a task sends it self to sleep
 149   1      // --------------------------------
 150   1        if (Handle == -1)
 151   1        {
 152   2          Tasks[RunningTask].State = TASK_SLEEPING;
 153   2          TimerSetTimeout(&Tasks[RunningTask].Timer ,TIMER0_MS_TO_TICKS(SleepTime));  
 154   2        }
 155   1        else
 156   1        {
 157   2          Tasks[Handle].State = TASK_SLEEPING;
 158   2          TimerSetTimeout(&Tasks[Handle].Timer ,TIMER0_MS_TO_TICKS(SleepTime)); 
 159   2        }
 160   1        
 161   1      }
 162          
 163          
 164          /****************************************************************************
 165           *
 166           *  NAME        : SchedulerRun
 167           *
 168           *
 169           *  DESCRIPTION : Run the scheduler                                     
 170           *
 171           ****************************************************************************/
 172          void SchedulerRun()
 173          {
C51 COMPILER V9.52.0.0   MINISCHEDULER                                                     04/28/2015 17:26:00 PAGE 4   

 174   1        BYTE xdata i;
 175   1      
 176   1        for (i = 0; i < NumOfTasks; i++)
 177   1        {
 178   2          // increment the running task pointer (with wrap around)
 179   2          // -----------------------------------------------------
 180   2          if (++RunningTask == NumOfTasks)
 181   2            RunningTask = 0;
 182   2          
 183   2        
 184   2          // if the task is resumed - run it
 185   2          // -------------------------------
 186   2          if (Tasks[RunningTask].State == TASK_RESUMED)
 187   2          {
 188   3            Tasks[RunningTask].State = TASK_RUNNING;
 189   3            Tasks[RunningTask].TaskPtr(Tasks[RunningTask].Argument);
 190   3            break;
 191   3          }
 192   2      
 193   2          // if the task is sleeping, check if it is wake up time
 194   2          // ----------------------------------------------------
 195   2          if (Tasks[RunningTask].State == TASK_SLEEPING)
 196   2          {
 197   3            if (TimerHasTimeoutExpired(&Tasks[RunningTask].Timer) == TRUE)
 198   3            {
 199   4              Tasks[RunningTask].State = TASK_RUNNING;
 200   4              Tasks[RunningTask].TaskPtr(Tasks[RunningTask].Argument);
 201   4              break;
 202   4            }
 203   3          }
 204   2      
 205   2        }
 206   1      }
 207          
 208          
 209          /****************************************************************************
 210           *
 211           *  NAME        : SchedulerGetTaskState
 212           *
 213           *
 214           *  DESCRIPTION : Get the state of a task                                     
 215           *
 216           ****************************************************************************/
 217          TTaskState SchedulerGetTaskState(TTaskHandle Handle)
 218          {
 219   1        return Tasks[Handle].State;
 220   1      }
 221          
 222          /****************************************************************************
 223           *
 224           *  NAME        : SchedulerGetTaskArg
 225           *
 226           *
 227           *  DESCRIPTION : Get the state of a task                                     
 228           *
 229           ****************************************************************************/
 230          BYTE SchedulerGetTaskArg(TTaskHandle Handle)
 231          {
 232   1        return Tasks[Handle].Argument;
 233   1      }
 234          
 235          
C51 COMPILER V9.52.0.0   MINISCHEDULER                                                     04/28/2015 17:26:00 PAGE 5   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    842    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    538    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
