C51 COMPILER V9.52.0.0   E2PROMINTERFACE                                                   04/28/2015 17:26:02 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE E2PROMINTERFACE
OBJECT MODULE PLACED IN .\Temp\E2PROMInterface.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE E2PROM\E2PROMInterface.c LARGE OPTIMIZE(0,SPEED) BROWSE INCDIR(..\SharedMod
                    -ules\SysDef,SPI\,..\SharedModules\RingBuffer,UART\,A2D\,..\SharedModules\Xilinx,..\SharedModules\EdenProtocol,Timer\,Pot
                    -entiometer\,HeaterControl\,E2PROM\,MsgDecode\,..\SharedModules\Utilities,..\SharedModules\Scheduler,..\SharedModules\Rol
                    -ler,Potentiometer\,PrintDriver\,Sensors\,HeadData\,Utils\,Watchdog\,Version\,Actuators\,D2A\,Comparator\,Bumper\) DEFINE
                    -(C8051F123_CPU) DEBUG OBJECTEXTEND PRINT(.\Temp\E2PROMInterface.lst) TABS(2) OBJECT(.\Temp\E2PROMInterface.obj)

line level    source

   1          /*===========================================================================
   2          *   FILENAME       : E2PROM Interface {E2PROMInterface.c}  
   3          *   PURPOSE        : Interface to the E2PROM device  
   4          *   DATE CREATED   : 17/Oct/2001
   5          *   PROGRAMMER     : Nir Saadon 
   6          *   PROCEDURES     : 
   7          *===========================================================================*/
   8          
   9          #ifdef OCB_SIMULATOR
              #include "c8051F120.h"
              #else 
  12          #include "c8051F120.h" // Keep it here for consistency with OCB_SIMULATOR define
  13          #endif
  14          
  15          #include "E2PROMInterface.h"
  16          #include "spidrv.h"
  17          #include <string.h>
  18          
  19          
  20          // Constants
  21          // =======================
  22          #define E2PROM_READ_INST     0x03
  23          #define E2PROM_WRITE_INST    0x02
  24          #define E2PROM_WRITE_ENABLE_INST 0x06
  25          #define E2PROM_BUFFER_LENGTH   100
  26          
  27          enum E2PROM_READ 
  28          {
  29            E2PROM_READ_INST_INDEX = 0,
  30            E2PROM_READ_ADDR_INDEX,
  31            E2PROM_READ_DUMMY_INDEX,
  32            E2PROM_READ_INST_LENGTH
  33          };
  34          
  35          enum E2PROM_WRITE 
  36          {
  37            E2PROM_WRITE_INST_INDEX = 0,
  38            E2PROM_WRITE_ADDR_INDEX,
  39            E2PROM_WRITE_DATA_INDEX,
  40            E2PROM_WRITE_INST_LENGTH
  41          };
  42          
  43          enum E2PROM_WRITE_ENABLE 
  44          {
  45            E2PROM_WRITE_ENABLE_INST_INDEX = 0,
  46            E2PROM_WRITE_ENABLE_INST_LENGTH
  47          };
  48          
  49          BYTE xdata E2PROMTransactionStatus;
  50          BYTE xdata E2PROMDataIn[E2PROM_BUFFER_LENGTH];
  51          
C51 COMPILER V9.52.0.0   E2PROMINTERFACE                                                   04/28/2015 17:26:02 PAGE 2   

  52          // This flag distinguish between write enable operation to write operation 
  53          BOOL xdata WriteEnable;
  54          
  55          sbit WRITE_PROTECT = P3^0;
  56          
  57          
  58          /****************************************************************************
  59          *
  60          *  NAME        : E2PROMInit
  61          *
  62          *  INPUT       : None
  63          *
  64          *  OUTPUT      : None
  65          *
  66          *  DESCRIPTION : Initialization of the E2PROM interface                                        
  67          *
  68          ****************************************************************************/
  69          void E2PROMInit()
  70          {
  71   1        E2PROMTransactionStatus = E2PROM_SEND_FAILED;
  72   1        WriteEnable             = FALSE;
  73   1      }
  74          
  75          
  76          /****************************************************************************
  77          *
  78          *  NAME        : E2PROMReadByte
  79          *
  80          *  INPUT       : E2PROM device number,
  81          *               Address,
  82          *               Pointer to the data buffer.
  83          *
  84          *  OUTPUT      : E2PROM_ERROR.
  85          *
  86          *  DESCRIPTION : Read one byte from an E2PROM device.                                        
  87          *
  88          ****************************************************************************/
  89          E2PROM_STATUS E2PROMReadByte(BYTE DeviceNum, WORD Address)
  90          {
  91   1        BYTE xdata Instruction, Addr8bit, Addr;
  92   1        BYTE xdata *Message;
  93   1      
  94   1        // try to lock the SPI device 
  95   1        if (SpiLock() == SPI_BUSY)
  96   1          return E2PROM_SEND_FAILED;
  97   1      
  98   1        // set the device status to busy  
  99   1        E2PROMTransactionStatus = E2PROM_BUSY;
 100   1      
 101   1        // prepare the address and the instruction byte 
 102   1        Addr        = (BYTE) Address;              // the lower 8 bit address
 103   1        Addr8bit    = (Address & 0x0100) << 3;     // take only the 9th bit of the address and shift to be the 3t
             -h bit
 104   1        Instruction = E2PROM_READ_INST | Addr8bit; // build the instruction byte from the read instruction  and t
             -he 9th bit address
 105   1      
 106   1        // prepare the message to be send using the spi 
 107   1        Message                          = SpiGetTxBuffer();
 108   1        Message[E2PROM_READ_INST_INDEX]  = Instruction;
 109   1        Message[E2PROM_READ_ADDR_INDEX]  = Addr;
 110   1        Message[E2PROM_READ_DUMMY_INDEX] = 0;
 111   1      
C51 COMPILER V9.52.0.0   E2PROMINTERFACE                                                   04/28/2015 17:26:02 PAGE 3   

 112   1        // Turn on the write protection (low) 
 113   1        WRITE_PROTECT = 0;
 114   1      
 115   1        // select the device (CS) 
 116   1        SpiSelectSlave(E2PROM_BASE_SLAVE_ID + DeviceNum,CHIP_SELECT);
 117   1      
 118   1        // send the message using the spi 
 119   1        SpiSend(E2PROM_READ_INST_LENGTH ,E2PROMDataIn, E2PROMCallBack);
 120   1        
 121   1        return E2PROM_NO_ERROR;     
 122   1      }
 123          
 124          
 125          /****************************************************************************
 126          *
 127          *  NAME        : E2PROMReadBlock
 128          *
 129          *  INPUT       : E2PROM device number,
 130          *               Address,
 131          *               Pointer to the data buffer,
 132          *               Number of bytes to read
 133          *
 134          *  OUTPUT      : E2PROM_ERROR.
 135          *
 136          *  DESCRIPTION : Read Length of bytes from an E2PROM device.                                        
 137          *
 138          ****************************************************************************/
 139          
 140          E2PROM_STATUS E2PROMReadBlock(BYTE DeviceNum, WORD Address, BYTE Length)
 141          {
 142   1        BYTE xdata Instruction, Addr8bit, Addr, index;
 143   1        BYTE xdata *Message;
 144   1        
 145   1        // try to lock the SPI device
 146   1        if (SpiLock() == SPI_BUSY)
 147   1          return E2PROM_SEND_FAILED;
 148   1      
 149   1        // set the device status to busy
 150   1        E2PROMTransactionStatus = E2PROM_BUSY;
 151   1      
 152   1        // prepare the address and the instruction byte
 153   1        Addr        = (BYTE) Address;              // the lower 8 bit address
 154   1        Addr8bit    = (Address & 0x0100) << 3;     // take only the 9th bit of the address and shift to be the 3t
             -h bit
 155   1        Instruction = E2PROM_READ_INST | Addr8bit; // build the instruction byte from the read instruction  and t
             -he 9th bit address
 156   1      
 157   1        // prepare the message to be send using the spi
 158   1        Message                         = SpiGetTxBuffer();
 159   1        Message[E2PROM_READ_INST_INDEX] = Instruction;
 160   1        Message[E2PROM_READ_ADDR_INDEX] = Addr;
 161   1        
 162   1        for (index = 0; index < Length; index++) 
 163   1          Message[E2PROM_READ_DUMMY_INDEX+index] = 0;
 164   1      
 165   1        // Turn on the write protection (low) 
 166   1        WRITE_PROTECT = 0;
 167   1      
 168   1        // select the device (CS)
 169   1        SpiSelectSlave(E2PROM_BASE_SLAVE_ID + DeviceNum,CHIP_SELECT);
 170   1      
 171   1        // send the message using the spi
C51 COMPILER V9.52.0.0   E2PROMINTERFACE                                                   04/28/2015 17:26:02 PAGE 4   

 172   1        SpiSend(E2PROM_READ_INST_LENGTH + Length - 1, E2PROMDataIn, E2PROMCallBack);
 173   1        
 174   1        return E2PROM_NO_ERROR; 
 175   1      }
 176          
 177          
 178          /****************************************************************************
 179          *
 180          *  NAME        : E2PROMWrite
 181          *
 182          *  INPUT       : E2PROM device number,
 183          *               Address,
 184          *               Data to be written.
 185          *
 186          *  OUTPUT      : E2PROM_ERROR.
 187          *
 188          *  DESCRIPTION : Write one byte to an E2PROM device.
 189          *               Call E2PROMWriteEnable first.                                        
 190          *
 191          ****************************************************************************/
 192          E2PROM_STATUS E2PROMWrite(BYTE DeviceNum, WORD Address, BYTE Data)
 193          {
 194   1        BYTE xdata Instruction, Addr8bit, Addr;
 195   1        BYTE xdata *Message;
 196   1      
 197   1        // deselect the device after the write enable inst
 198   1        SpiSelectSlave(E2PROM_BASE_SLAVE_ID + DeviceNum,CHIP_DESELECT);
 199   1      
 200   1        // set the device status to busy
 201   1        E2PROMTransactionStatus = E2PROM_BUSY;
 202   1      
 203   1        // prepare the address and the instruction byte
 204   1        Addr        = (BYTE) Address;               // the lower 8 bit address
 205   1        Addr8bit    = (Address & 0x0100) << 3;      // take only the 9th bit of the address and shift to be the 3
             -th bit
 206   1        Instruction = E2PROM_WRITE_INST | Addr8bit; // build the instruction byte from the write instruction  and
             - the 9th bit address
 207   1      
 208   1        // prepare the message to be send using the spi
 209   1        Message                          = SpiGetTxBuffer();
 210   1        Message[E2PROM_WRITE_INST_INDEX] = Instruction;
 211   1        Message[E2PROM_WRITE_ADDR_INDEX] = Addr;
 212   1        Message[E2PROM_WRITE_DATA_INDEX] = Data;
 213   1      
 214   1        WriteEnable = FALSE;
 215   1      
 216   1        // select the device (CS) 
 217   1        SpiSelectSlave(E2PROM_BASE_SLAVE_ID + DeviceNum,CHIP_SELECT);
 218   1      
 219   1        // send the message using the spi 
 220   1        SpiSend(E2PROM_WRITE_INST_LENGTH ,E2PROMDataIn, E2PROMCallBack);
 221   1        
 222   1        return E2PROM_NO_ERROR;
 223   1      }
 224          
 225          
 226          /****************************************************************************
 227          *
 228          *  NAME        : E2PROMWriteBlock
 229          *
 230          *  INPUT       : E2PROM device number,
 231          *               Address,
C51 COMPILER V9.52.0.0   E2PROMINTERFACE                                                   04/28/2015 17:26:02 PAGE 5   

 232          *               Pointer to the data buffer,
 233          *               Number of bytes to write
 234          *
 235          *  OUTPUT      : E2PROM_ERROR.
 236          *
 237          *  DESCRIPTION : Write Length of bytes (up to 16, on the same page) to an E2PROM device.
 238          *               Call E2PROMWriteEnable first.                                        
 239          *
 240          ****************************************************************************/
 241          
 242          E2PROM_STATUS E2PROMWriteBlock(BYTE DeviceNum, WORD Address, BYTE *Data, BYTE Length)
 243          {
 244   1        BYTE xdata Instruction, Addr8bit, Addr, index;
 245   1        BYTE xdata *Message;
 246   1      
 247   1        // deselect the device after the write enable inst.
 248   1        SpiSelectSlave(E2PROM_BASE_SLAVE_ID + DeviceNum,CHIP_DESELECT);
 249   1      
 250   1        // set the device status to busy  
 251   1        E2PROMTransactionStatus = E2PROM_BUSY;
 252   1      
 253   1        // check if all the bytes are on the same page
 254   1        if (((Address + Length - 1)/16) > (Address/16))
 255   1          return E2PROM_WRITE_BLOCK_ERORR;
 256   1      
 257   1        // prepare the address and the instruction byte
 258   1        Addr        = (BYTE) Address;   // the lower 8 bit address
 259   1        Addr8bit    = (Address & 0x0100) << 3; // take only the 9th bit of the address and shift to be the 3th bi
             -t
 260   1        Instruction = E2PROM_WRITE_INST | Addr8bit; //build the instruction byte from the write instruction  and 
             -the 9th bit address
 261   1      
 262   1        // prepare the message to be send using the spi
 263   1        Message                          = SpiGetTxBuffer();
 264   1        Message[E2PROM_WRITE_INST_INDEX] = Instruction;
 265   1        Message[E2PROM_WRITE_ADDR_INDEX] = Addr;
 266   1        
 267   1        for (index = 0; index < Length; index++)
 268   1          Message[E2PROM_WRITE_DATA_INDEX+index] = Data[index];
 269   1      
 270   1        WriteEnable = FALSE;
 271   1      
 272   1        // select the device (CS)
 273   1        SpiSelectSlave(E2PROM_BASE_SLAVE_ID + DeviceNum,CHIP_SELECT);
 274   1      
 275   1        // send the message using the spi
 276   1        SpiSend(E2PROM_WRITE_INST_LENGTH + Length - 1, E2PROMDataIn,E2PROMCallBack);
 277   1        
 278   1        return E2PROM_NO_ERROR;
 279   1      }
 280          
 281          
 282          /****************************************************************************
 283          *
 284          *  NAME        : E2PROMWriteEnable
 285          *
 286          *  INPUT       : E2PROM device number,
 287          *               Address,
 288          *               Data to be written.
 289          *
 290          *  OUTPUT      : E2PROM_ERROR.
 291          *
C51 COMPILER V9.52.0.0   E2PROMINTERFACE                                                   04/28/2015 17:26:02 PAGE 6   

 292          *  DESCRIPTION : Sends a Write enable instruction to an E2PROM device.
 293          *               Call this function before calling E2PROMWrite() or E2PROMWriteBlock()                            
             -           
 294          *
 295          ****************************************************************************/
 296          E2PROM_STATUS E2PROMWriteEnable(BYTE DeviceNum)
 297          {
 298   1        BYTE xdata *Message;
 299   1      
 300   1        // try to lock the SPI device 
 301   1        if (SpiLock() == SPI_BUSY)
 302   1          return E2PROM_SEND_FAILED;
 303   1      
 304   1        // set the device status to busy  
 305   1        E2PROMTransactionStatus = E2PROM_BUSY;
 306   1      
 307   1        // Turn off the write protection (high) (should stay high until the end of the writing) 
 308   1        WRITE_PROTECT = 1;
 309   1      
 310   1        WriteEnable = TRUE;
 311   1      
 312   1        // prepare a write enable instruction 
 313   1        Message = SpiGetTxBuffer();
 314   1        Message[E2PROM_WRITE_ENABLE_INST_INDEX] = E2PROM_WRITE_ENABLE_INST;
 315   1      
 316   1        // select the device (CS) 
 317   1        SpiSelectSlave(E2PROM_BASE_SLAVE_ID + DeviceNum,CHIP_SELECT);
 318   1      
 319   1        // send the message using the spi 
 320   1        SpiSend(E2PROM_WRITE_ENABLE_INST_LENGTH ,E2PROMDataIn, E2PROMCallBack);
 321   1      
 322   1        return E2PROM_NO_ERROR;
 323   1      }
 324          
 325          /****************************************************************************
 326          *
 327          *  NAME        : E2PROMCallBack
 328          *
 329          *  INPUT       : Transaction status
 330          *
 331          *  OUTPUT      : None.
 332          *
 333          *  DESCRIPTION : Called from the spi ISR, updates the transaction status.                                 
             -       
 334          *
 335          ****************************************************************************/
 336          void E2PROMCallBack(BYTE Status) using 3
 337          {
 338   1        if (Status == SPI_NO_ERROR)
 339   1          E2PROMTransactionStatus = E2PROM_SEND_SUCCESS;
 340   1        else
 341   1          E2PROMTransactionStatus = E2PROM_SEND_FAILED;
 342   1      }
 343          
 344          /****************************************************************************
 345          *
 346          *  NAME        : E2PROMGetReceivedData
 347          *
 348          *  INPUT       : Data buffer, Data length
 349          *
 350          *  OUTPUT      : E2PROM_ERROR.
 351          *
C51 COMPILER V9.52.0.0   E2PROMINTERFACE                                                   04/28/2015 17:26:02 PAGE 7   

 352          *  DESCRIPTION : .                                        
 353          *
 354          ****************************************************************************/
 355          E2PROM_STATUS E2PROMGetReceivedData(BYTE DeviceNum, BYTE *Data, BYTE Length)
 356          {
 357   1        // if the spi operation is not done yet 
 358   1        if (E2PROMTransactionStatus == E2PROM_BUSY) 
 359   1          return E2PROM_BUSY; 
 360   1      
 361   1        if (E2PROMTransactionStatus == E2PROM_SEND_SUCCESS)
 362   1        {
 363   2          if (Length == 1)          // save the memcpy overhead
 364   2            *Data = E2PROMDataIn[2];  // the two first byte is junk received after th read insturction
 365   2          else
 366   2            memcpy (Data, &(E2PROMDataIn[2]), Length); // the tow first byte is junk received after th read insturc
             -tion
 367   2        }
 368   1      
 369   1        // deselect the device (CS) 
 370   1        SpiSelectSlave(E2PROM_BASE_SLAVE_ID + DeviceNum,CHIP_DESELECT);
 371   1      
 372   1        // unlock the spi since the operation is done 
 373   1        SpiUnLock();
 374   1      
 375   1        return E2PROMTransactionStatus; 
 376   1      }
 377          
 378          
 379          /****************************************************************************
 380          *
 381          *  NAME        : E2PROMGetWriteStatus
 382          *
 383          *  INPUT       : NONE
 384          *
 385          *  OUTPUT      : E2PROM_ERROR.
 386          *
 387          *  DESCRIPTION : Return the status of the last write operation.
 388          *               Call it after E2PROMWriteByte or E2PROMWriteBlock                                        
 389          *
 390          ****************************************************************************/
 391          E2PROM_STATUS E2PROMGetWriteStatus(BYTE DeviceNum)
 392          {
 393   1        // if the spi operation is not done yet 
 394   1        if (E2PROMTransactionStatus == E2PROM_BUSY) 
 395   1          return E2PROM_BUSY; 
 396   1      
 397   1        // deselect the device (CS) 
 398   1        SpiSelectSlave(E2PROM_BASE_SLAVE_ID + DeviceNum,CHIP_DESELECT);
 399   1      
 400   1        // Turn on the write protection (low) 
 401   1        if (!WriteEnable)
 402   1        {
 403   2          WRITE_PROTECT = 0;
 404   2      
 405   2          // unlock the spi since the operation is done   
 406   2          SpiUnLock();
 407   2        }
 408   1      
 409   1        return E2PROMTransactionStatus;
 410   1      }
 411          

C51 COMPILER V9.52.0.0   E2PROMINTERFACE                                                   04/28/2015 17:26:02 PAGE 8   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1450    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    152    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
