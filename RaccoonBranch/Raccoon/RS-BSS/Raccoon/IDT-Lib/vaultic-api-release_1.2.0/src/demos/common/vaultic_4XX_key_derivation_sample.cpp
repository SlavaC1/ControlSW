// vaultic_4XX_key_derivation_sample.cpp : Defines the entry point for the console application.
//

#include "common.h"

#define USER_PIN_ID			0x00

#define DOMAIN_P192       0x01
#define DOMAIN_P224       0x02
#define DOMAIN_P256       0x03
#define DOMAIN_P384       0x04
#define DOMAIN_P521       0x05
#define DOMAIN_B571       0x06
#define DOMAIN_B409       0x07
#define DOMAIN_B283       0x08
#define DOMAIN_B233       0x09
#define DOMAIN_B163       0x0A
#define DOMAIN_K571       0x0B
#define DOMAIN_K409       0x0C
#define DOMAIN_K283       0x0D
#define DOMAIN_K233       0x0E
#define DOMAIN_K163       0x0F

#ifndef USE_STATIC_API
/*******************************************************
 VaultIC SDK DLL Methods:
*******************************************************/
typedef VLT_STS (*pfnInitLibrary)(VLT_INIT_COMMS_PARAMS* initCommsParams);
typedef VLT_STS (*pfnCloseLibrary)(void);
typedef VAULTIC_API* (*pfnGetApi)(void);
typedef VAULTIC_AUTH* (*pfnGetAuth)( void );
typedef VAULTIC_KEY_WRAPPING* (*pfnGetKeyWrapping)( void );
typedef VLT_STS (*pfnGetLibraryInfo)( VLT_LIBRARY_INFO* pLibraryInfo );
typedef VLT_STS (*pfnFindDevices)( VLT_PU32 pSize, VLT_PU8 pXmlReaderString );
#endif

using namespace std;

#define SUPPORTED( flags, value )   static_cast<bool>(( flags & value ) == value )

#if( VLT_PLATFORM == VLT_WINDOWS )
int _tmain(int argc, _TCHAR* argv[])
#else
int main(int argc, char** argv)
#endif
{ 
#if( VLT_PLATFORM == VLT_WINDOWS )
    HMODULE hMod = NULL;
#else
    void* hMod = NULL;
#endif 
    
#ifndef USE_STATIC_API   
    pfnGetApi VltGetApi;
    pfnGetAuth VltGetAuth;
    pfnInitLibrary VltInitLibrary;
    pfnCloseLibrary VltCloseLibrary;
    pfnGetLibraryInfo VltGetLibraryInfo;
    pfnFindDevices VltFindDevices;
#endif   

    string strXMLDevs;
    const unsigned char ucMinPasswordLength = 4;
    const unsigned char ucMaxPasswordLength = 32;
    const unsigned short usStartupDelay_1_0_X = 15000;
    const unsigned short usStartupDelay_1_1_0 = 2500;
    unsigned short usActualSW = 0;
	long lPrefferedInterface = 0;

    VAULTIC_API* theBaseApi = 0;
    VAULTIC_AUTH* theAuthSvr = 0;
    //
    // Check the command line arguments are valid
    //
    if ( 2 > argc )
    {
        cout << "Please ensure the manufacturer's password has "
            "been passed in using the command line:" << endl;
	
        return( 1 );
    }

    std::string strManufPassword(argv[1]);
    unsigned char ucManufPasswordLength = (unsigned char)strManufPassword.size();

    //
    // Check the supplied password is a valid length.
    //
    if ( ( ucManufPasswordLength < ucMinPasswordLength ) ||
         ( ucManufPasswordLength > ucMaxPasswordLength ) )
		 CloseAndExit(hMod,1,"Please ensure the manufacturer's password is between 4 characters and 32 characters"); 
    
	if (3 == argc)
	{
		lPrefferedInterface = strtol(argv[2], NULL, 10);
	}

    try
    {
#ifndef USE_STATIC_API 
       //
        // The path to the library is stored in the project settings.
        hMod = OpenLibrary( LIB_PATH_4XX );
        
        if (hMod == NULL)
        {
    	    return ( VLT_GETPROC_INIT_LIB_FAILED );
        }   
       
        //
        // Get the function pointer to the VltInitLibrary method.  
        // This method is used to initialise the entire API, it may 
        // allocated resources as required.
        if( NULL == ( VltInitLibrary = (pfnInitLibrary)GetLibSymbol( hMod,
            "VltInitLibrary" ) ) )
			CloseAndExit(hMod,VLT_GETPROC_INIT_LIB_FAILED,"GetLibSymbol (VltInitLibrary) failed");       
        
        //
        // Get the function pointer to the VltCloseLibrary method.  This method
        // is used release resources allocated by previous API calls.
        if( NULL == ( VltCloseLibrary = (pfnCloseLibrary)GetLibSymbol( hMod,
            "VltCloseLibrary" ) ) )
			CloseAndExit(hMod,VLT_GETPROC_ClOSE_LIB_FAILED,"GetLibSymbol (VltCloseLibrary) failed");          

        //    
        // Get the function pointer to the VltGetApi method.  This method
        // is used to obtain a pointer to the API Interface 
        if( NULL == ( VltGetApi = (pfnGetApi)GetLibSymbol( hMod, "VltGetApi" ) ) )
			CloseAndExit(hMod,VLT_GETPROC_GET_API_FAILED,"GetLibSymbol (VltGetApi) failed");       
        
        //    
        // Get the function pointer to the VltGetScp method.  This method
        // is used to obtain a pointer to structure of Secure Channel Protocol
        // service Interface.
        if( NULL == ( VltGetAuth = (pfnGetAuth)GetLibSymbol( hMod, "VltGetAuth" ) ) )
			CloseAndExit(hMod,VLT_GETPROC_GET_AUTH_FAILED,"GetLibSymbol (VltGetAuth) failed"); 
      
        //    
        // Get the function pointer to the VltGetLibraryInfo method. This method
        // is used to obtain information about the library.
        if( NULL == ( VltGetLibraryInfo = (pfnGetLibraryInfo)GetLibSymbol( hMod, "VltGetLibraryInfo" ) ) )
			CloseAndExit(hMod,VLT_GETPROC_GET_LIBINFO_FAILED,"GetLibSymbol (VltGetLibraryInfo) failed"); 
        
        //    
        // Get the function pointer to the VltGetLibraryInfo method. This method
        // is used to obtain information about the library.
        if( NULL == ( VltFindDevices = (pfnFindDevices)GetLibSymbol( hMod, "VltFindDevices" ) ) )
			CloseAndExit(hMod,VLT_GETPROC_GET_FINDDEVS_FAILED,"GetLibSymbol (VltFindDevices) failed"); 
  #endif 

        VLT_LIBRARY_INFO libInfo;
        VLT_STS status = VLT_FAIL;

        //
        // Determine the library capabilities and print those out in the 
        // standard output. 
        //
        if( VLT_OK != ( status = VltGetLibraryInfo( &libInfo ) ) )
        {
#ifndef USE_STATIC_API
            CloseLibrary( hMod );
#endif
            return( status );
        }

        else
        {
            cout << "==========================================================" << endl;
            cout << "                  Library Information                     " << endl;
            cout << "==========================================================" << endl;
            cout << "Library version : " << libInfo.pVersion << endl;
                        
            cout << "    Put/Read Secret Key Support Enabled : " << boolalpha << 
                SUPPORTED( libInfo.capabilities, VLT_CPB_ENABLE_KEY_SECRET ) << endl;
            cout << "    Put/Read HOTP Key Support Enabled: " << boolalpha << 
                SUPPORTED( libInfo.capabilities, VLT_CPB_ENABLE_KEY_HOTP ) << endl;
            cout << "    Put/Read TOTP Key Support Enabled: " << boolalpha << 
                SUPPORTED( libInfo.capabilities, VLT_CPB_ENABLE_KEY_TOTP ) << endl;
            cout << "    Put/Read RSA Key Support Enabled : " << boolalpha << 
                SUPPORTED( libInfo.capabilities, VLT_CPB_ENABLE_KEY_RSA ) << endl;
            cout << "    Put/Read DSA Key Support Enabled : " << boolalpha << 
                SUPPORTED( libInfo.capabilities,  VLT_CPB_ENABLE_KEY_DSA ) << endl;
            cout << "    Put/Read ECDSA Key Support Enabled : " << boolalpha << 
                SUPPORTED( libInfo.capabilities,  VLT_CPB_ENABLE_KEY_ECDSA ) << endl;
            cout << "    Cipher Self Tests Support Enabled : " << boolalpha << 
                SUPPORTED( libInfo.capabilities, VLT_CPB_ENABLE_CIPHER_TESTS ) << endl;
            cout << "    Identity Authentication Service Support Enabled: " << boolalpha <<
                SUPPORTED( libInfo.capabilities,  VLT_CPB_ENABLE_IDENTITY_AUTH )<< endl; 
            cout << "    SCP02 Secure Channel Support Enabled: " << boolalpha << 
                SUPPORTED( libInfo.capabilities,  VLT_CPB_ENABLE_SCP02 ) << endl;
            cout << "    SCP03 Secure Channel Support Enabled: " << boolalpha << 
                SUPPORTED( libInfo.capabilities,  VLT_CPB_ENABLE_SCP03 ) << endl;
            cout << "    Microsoft Minicard Driver Support Enabled: " << boolalpha << 
                SUPPORTED( libInfo.capabilities,  VLT_CPB_ENABLE_MS_AUTH ) << endl;
            cout << "    Block Protocol Support Enabled: " << boolalpha << 
                SUPPORTED( libInfo.capabilities,  VLT_CPB_ENABLE_BLOCK_PROTOCOL ) << endl;
            cout << "    TWI Interface Support Enabled: " << boolalpha <<             
                SUPPORTED( libInfo.capabilities,  VLT_CPB_ENABLE_TWI ) << endl;
            cout << "    SPI Interface Support Enabled: " << boolalpha <<
                SUPPORTED( libInfo.capabilities,  VLT_CPB_ENABLE_SPI ) << endl;
            cout << "    ISO7816 Protocol Support Enabled: " << boolalpha <<             
                SUPPORTED( libInfo.capabilities,  VLT_CPB_ENABLE_ISO7816 ) << endl;           
            cout << "    AES(128, 192, 256) Support Enabled: " << boolalpha <<
                SUPPORTED( libInfo.capabilities,  VLT_CPB_ENABLE_CIPHER_AES ) << endl;
            cout << "    TDES(EEE& EDE modes) Support Enabled: " << boolalpha <<
                SUPPORTED( libInfo.capabilities,  VLT_CPB_ENABLE_CIPHER_TDES ) << endl;
            cout << "    DES Support Enabled: " << boolalpha <<
                SUPPORTED( libInfo.capabilities,  VLT_CPB_ENABLE_CIPHER_DES ) << endl;
            cout << "    Fast CRC16 CCIT Support Enabled: " << boolalpha <<
                SUPPORTED( libInfo.capabilities,  VLT_CPB_ENABLE_FAST_CRC16CCIT ) << endl;
            cout << "    Key Wrapping Service Support Enabled: " << boolalpha <<
                SUPPORTED( libInfo.capabilities,  VLT_CPB_ENABLE_KEY_WRAPPING ) << endl;
            cout << "    Put/Read Host/Device ID Key Support Enabled: " << boolalpha <<
                SUPPORTED( libInfo.capabilities,  VLT_ENABLE_KEY_HOST_DEVICE_ID ) << endl;
            cout << "    File System Service Support Enabled: " << boolalpha <<
                SUPPORTED( libInfo.capabilities,  VLT_ENABLE_FILE_SYSTEM ) << endl;
            cout << "    Aardvark SPI Write Error suppresion support Enabled: " << boolalpha <<
                SUPPORTED( libInfo.capabilities,  VLT_ENABLE_AARDVK_SPPRSS_ERR ) << endl;
            

            if( libInfo.fwCompatibilityVersionId == 1 )
            {
                cout << "This Library is compiled for VaultIC version: v1.0.2" << endl;
            }
            if( libInfo.fwCompatibilityVersionId == 2 )
            {
                cout << "This Library is compiled for VaultIC version: v1.1.x" << endl;
            }
        }

		//
        // Determine the size of the xml string that will be returned on the second call, 
        // set the stringSize parameter to zero and the string to NULL. On return the 
        // stringSize will be set to the actual number of characters of the XML string 
        // that contains the list of devices.
        //
        VLT_U32 stringSize = 0;
        if( VLT_OK != ( status = VltFindDevices( &stringSize, NULL ) ) )
        	CloseAndExit(hMod,status,"Find device failed"); 

        //
        // Allocate enough memory to hold the xml string with the list of
        // devices.
        //
        VLT_PU8 pXmlString = (VLT_PU8)NULL;
        if( NULL == ( pXmlString = (VLT_PU8)malloc(stringSize ) ) ) 
			CloseAndExit(hMod,VLT_FIND_DEVS_MALLOC_FAIL,"Memory allocation failed"); 

        //
        // Now call the VltFindDevices again with all the appropriate parameters
        // On return the pXmlString will be filled with the device list.
        //
        if( VLT_OK != ( status = VltFindDevices( &stringSize, pXmlString ) ) )
        {
            if( NULL != pXmlString )
            {
                free( pXmlString );
                pXmlString = NULL;
            }

			CloseAndExit(hMod,status,"Find device failed (malformated XML)");
        }
        else
        {
            std::cout << pXmlString << endl;
            
            //
            // Assign the XML string to a standard string
            //
            strXMLDevs =(const char*)pXmlString;
        }

        if( NULL != pXmlString )
        {
            free( pXmlString );
            pXmlString = NULL;
        }

        VLT_INIT_COMMS_PARAMS commsParams;

        //
        // Check if there are any PC/SC readers connected
        //
        size_t startPos = 0;
        size_t endPos = 0;
        string strReaderName("");
		
		bool readerFound = false;
		unsigned char item = 0;
		long selection = 0;
#if(VLT_ENABLE_ISO7816 == VLT_ENABLE )  
      	//
		// Check if the XML string includes an entry for PC/SC readers
		//
		startPos = strXMLDevs.find("<interface type=\"pcsc\">");
		if( string::npos != startPos )
		{
			endPos = strXMLDevs.find("</interface>");
			if( string::npos == endPos )
				CloseAndExit(hMod,VLT_MALFORMED_XML_PCSC_INTFC,"Find device failed (malformated XML)"); 

			string strPCSC( strXMLDevs.substr( startPos, ( endPos - startPos ) ) );

			printf("\nList of detected PC/SC interfaces:");
			printf("\n==================================\n\n");

			// Reset start pointer & item number
			startPos = 0;
			item = 0;

			do
			{
				//
				// It does so check for entries for a reader
				//
				startPos = strPCSC.find("<peripheral idx=", startPos);
				if (string::npos == startPos)
				{
					// No more reader in the list = end of loop
					break;
				}
				{
					//
					// Start of the reader name is after the opening tag
					//
					startPos += strlen("<peripheral idx=\"00\">");

					//
					// End position is at beginning of the closing tag
					//
					endPos = strPCSC.find("</peripheral>", startPos);
					if (string::npos == endPos)
						CloseAndExit(hMod, VLT_MALFORMED_XML_PCSC_PERIPH, "Find device failed (malformated XML)");

					//
					// Get the reader name
					//
					strReaderName = strPCSC.substr(startPos, (endPos - startPos));
					
					// Display the reader name
					printf("Interface #%d, SmartCard Reader Name = %s\n", item++ + INTERFACE_PCSC, strReaderName.c_str());

					readerFound = true;
				} 
			} while (true);
		}
#endif 
#if(VLT_ENABLE_CHEETAH == VLT_ENABLE )
					//
		// Check if the XML string includes an entry for PC/SC readers
		//
		startPos = strXMLDevs.find("<interface type=\"cheetah\">");
		if( string::npos != startPos )
		{
			endPos = strXMLDevs.find("</interface>");
			if( string::npos == endPos )
				CloseAndExit(hMod,VLT_MALFORMED_XML_CHEETH_INTFC,"Find device failed (malformated XML)"); 

			string strPCSC( strXMLDevs.substr( startPos, ( endPos - startPos ) ) );

			printf("\nList of detected cheetah interfaces:");
			printf("\n==================================\n\n");

			// Reset start pointer & item number
			startPos = 0;
			item = 0;

			do
			{
				//
				// It does so check for entries for a reader
				//
				startPos = strPCSC.find("<peripheral idx=", startPos);
				if (string::npos == startPos)
				{
					// No more reader in the list = end of loop
					break;
				}
				{
					//
					// Start of the reader name is after the opening tag
					//
					startPos += strlen("<peripheral idx=\"00\">");

					//
					// End position is at beginning of the closing tag
					//
					endPos = strPCSC.find("</peripheral>", startPos);
					if (string::npos == endPos)
						CloseAndExit(hMod, VLT_MALFORMED_XML_CHEETH_PERIPH, "Find device failed (malformated XML)");

					//
					// Get the reader name
					//
					strReaderName = strPCSC.substr(startPos, (endPos - startPos));
					
					// Display the reader name
					printf("Interface #%d, Cheetah SPI Serial Number = %s\n", item++ + INTERFACE_CHEETAH_SPI, strReaderName.c_str());

					readerFound = true;
				} 
			} while (true);
		}
#endif
#if(VLT_ENABLE_AARDVARK == VLT_ENABLE )
		startPos = strXMLDevs.find( "<interface type=\"aardvark\">" );
		if( string::npos != startPos )
		{
			endPos = strXMLDevs.find( "</interface>" , startPos);
			if( string::npos == endPos)
				CloseAndExit(hMod,VLT_MALFORMED_XML_AARDVARK_INTFC,"Find device failed (malformated XML)");

			string strAardvark( strXMLDevs.substr( startPos, ( endPos - startPos ) ) );

			printf("\nList of detected Aardvark interfaces:");
			printf("\n=====================================\n\n");
			
			// Reset start pointer & item number
			startPos = 0;
			item = 0;

			do
			{
				//
				// It does so check for entries for a reader
				//
				startPos = strAardvark.find("<peripheral idx=", startPos);
				if (string::npos == startPos)
				{
					// No more reader in the list = end of loop
					break;
				}
				else
				{
					//
					// Start of the reader name is after the opening tag
					//
					startPos += strlen("<peripheral idx=\"00\">");

					//
					// End position is at beginning of the closing tag
					//
					endPos = strAardvark.find("</peripheral>", startPos);
					if (string::npos == endPos)
						CloseAndExit(hMod, VLT_MALFORMED_XML_AARDVARK_PERIPH, "Find device failed (malformated XML)");

					//
					// Get the Aardwark serial number
					//
					strReaderName = strAardvark.substr(startPos, (endPos - startPos));

					// Display the reader name
					printf("Interface #%d; Aardvark SPI Serial Number = %s\n", INTERFACE_AARDVARK_SPI + item,	strReaderName.c_str());
					printf("Interface #%d; Aardvark TWI Serial Number = %s\n", INTERFACE_AARDVARK_TWI + item++, strReaderName.c_str());

					readerFound = true;
				}
			} while (true);
		}
#endif
		if (!readerFound)
		{
			CloseAndExit(hMod,VLT_NO_READER_CONNECTED,"No reader connected");
		}

		// If no preferred interface is provide
		if (lPrefferedInterface == 0)
		{
			// -> Prompt the user to select the communication interface
			printf("\n\nPlease enter the interface number, followed by ENTER: ");
			scanf("%02d", &selection); getchar();
			printf("\n\n");
		}
		else
		{
			// -> Automatically select the preferred interface
			printf("\n\nThe interface #%02d is automatically selected.\n", lPrefferedInterface);
			printf("\n\n");
			selection = lPrefferedInterface;
		}

		char pXmlData[30];

		unsigned char protocol = (selection / 10) * 10;
		unsigned char idx = selection % 10;

		sprintf((char*)pXmlData, (const char*)"<peripheral idx=\"%02d\">", idx);

		switch (protocol)
		{

#if(VLT_ENABLE_ISO7816 == VLT_ENABLE )  
		case INTERFACE_PCSC:
			startPos = strXMLDevs.find("<interface type=\"pcsc\">");
			startPos = strXMLDevs.find(pXmlData, startPos);
			startPos += strlen(pXmlData);
			endPos = strXMLDevs.find("</peripheral>", startPos);

			// Get the reader name
			strReaderName = strXMLDevs.substr(startPos, (endPos - startPos));

			// Setup communications using PCSC T=0
			commsParams.Params.VltPcscInitParams.hCard = 0;
			commsParams.Params.VltPcscInitParams.hContext = 0;
			commsParams.Params.VltPcscInitParams.pu8ReaderString = (VLT_PU8)strReaderName.c_str();

			commsParams.u8CommsProtocol = VLT_ISO_T0_OR_T1_COMMS;

			break;
#endif

#if(VLT_ENABLE_CHEETAH == VLT_ENABLE )  
		case INTERFACE_CHEETAH_SPI:
			startPos = strXMLDevs.find("<interface type=\"cheetah\">");
			startPos = strXMLDevs.find(pXmlData, startPos);
			startPos += strlen(pXmlData);
			endPos = strXMLDevs.find("</peripheral>", startPos);

			// Get the reader name
			strReaderName = strXMLDevs.substr(startPos, (endPos - startPos));

			commsParams.u8CommsProtocol = VLT_SPI_COMMS;

			commsParams.Params.VltBlockProtocolParams.u16BitRate = 8800;
			commsParams.Params.VltBlockProtocolParams.u8CheckSumMode = BLK_PTCL_CHECKSUM_SUM8;
			commsParams.Params.VltBlockProtocolParams.u32AfterHdrDelay = 6;
			commsParams.Params.VltBlockProtocolParams.u32InterBlkDelay = 160;
			commsParams.Params.VltBlockProtocolParams.u32InterHdrByteDelay = 3;

			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.PeriphParams.VltSpiParams.u8AdapterType = VLT_SPI_CHEETAH_ADAPTER;
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.u32SerialNo = strtoul( strReaderName.c_str(), NULL, 10 );
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.PeriphParams.VltSpiParams.u32FstPollByteDelay = 6;
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.PeriphParams.VltSpiParams.u32IntPollByteDelay = 5;
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.PeriphParams.VltSpiParams.u32IntByteDelay = 0;
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.PeriphParams.VltSpiParams.u32PollMaxRetries = 800000;
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.PeriphParams.VltSpiParams.u32SlaveSelectDelay = 4;

			//
			// Add a delay to allow self tests to run before establishing comms.
			//
			if( libInfo.fwCompatibilityVersionId == 1 )
			{
				commsParams.Params.VltBlockProtocolParams.u16msSelfTestDelay = usStartupDelay_1_0_X;
			}
			if( libInfo.fwCompatibilityVersionId == 2 )
			{
				commsParams.Params.VltBlockProtocolParams.u16msSelfTestDelay = usStartupDelay_1_1_0;
			}
			break;
#endif
#if(VLT_ENABLE_AARDVARK == VLT_ENABLE )  
		case INTERFACE_AARDVARK_TWI:
			startPos = strXMLDevs.find("<interface type=\"aardvark\">");
			startPos = strXMLDevs.find(pXmlData, startPos);
			startPos += strlen(pXmlData);
			endPos = strXMLDevs.find("</peripheral>", startPos);

			// Get the reader name
			strReaderName = strXMLDevs.substr(startPos, (endPos - startPos));

			// Setup communications using TWI over Aarvark
			commsParams.u8CommsProtocol = VLT_TWI_COMMS;
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.PeriphParams.VltTwiParams.u16BusTimeout = 250;
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.PeriphParams.VltTwiParams.u32msTimeout = 4000;
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.PeriphParams.VltTwiParams.u8Address = 0x5F;
			commsParams.Params.VltBlockProtocolParams.u16BitRate = 100;
			commsParams.Params.VltBlockProtocolParams.u8CheckSumMode = BLK_PTCL_CHECKSUM_SUM8;
			commsParams.Params.VltBlockProtocolParams.u32AfterHdrDelay = 1000;
			commsParams.Params.VltBlockProtocolParams.u32InterBlkDelay = 1000;
			commsParams.Params.VltBlockProtocolParams.u32InterHdrByteDelay = 1000;
			commsParams.Params.VltBlockProtocolParams.u16msSelfTestDelay = 2500;
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.u32SerialNo = strtoul(strReaderName.c_str(), NULL, 10);

			break;
		case INTERFACE_AARDVARK_SPI:
			startPos = strXMLDevs.find("<interface type=\"aardvark\">");
			startPos = strXMLDevs.find(pXmlData, startPos);
			startPos += strlen(pXmlData);
			endPos = strXMLDevs.find("</peripheral>", startPos);

			// Get the reader name
			strReaderName = strXMLDevs.substr(startPos, (endPos - startPos));

			// Setup communications using TWI over Aarvark
			commsParams.u8CommsProtocol = VLT_SPI_COMMS;
			commsParams.Params.VltBlockProtocolParams.u16BitRate		= 125;
			commsParams.Params.VltBlockProtocolParams.u8CheckSumMode	= BLK_PTCL_CHECKSUM_SUM8;
			commsParams.Params.VltBlockProtocolParams.u32AfterHdrDelay	= 1000;	
			commsParams.Params.VltBlockProtocolParams.u32InterBlkDelay	= 1000;	
			commsParams.Params.VltBlockProtocolParams.u32InterHdrByteDelay = 1000;
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.PeriphParams.VltSpiParams.u8AdapterType = VLT_SPI_AARDVARK_ADAPTER;
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.u32SerialNo = strtoul( strReaderName.c_str(), NULL, 10 );
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.PeriphParams.VltSpiParams.u32FstPollByteDelay = 3000;
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.PeriphParams.VltSpiParams.u32IntPollByteDelay = 3000;
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.PeriphParams.VltSpiParams.u32IntByteDelay = 1000; //NO effect useless for aardvark
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.PeriphParams.VltSpiParams.u32PollMaxRetries = 1000;
			commsParams.Params.VltBlockProtocolParams.VltPeripheralParams.PeriphParams.VltSpiParams.u32SlaveSelectDelay = 1000; //NO effect useless for aardvark
			//
			// Add a delay to allow self tests to run before establishing comms.
			//
			commsParams.Params.VltBlockProtocolParams.u16msSelfTestDelay = 4000;

			break;
#endif
		default:
			CloseAndExit(hMod,VLT_NO_READER_CONNECTED,"Invalid selection\n");
		}
 

       	//
		// Get the Api Interface.
		if ( 0 == ( theBaseApi = VltGetApi( ) ) )
		{
			CloseAndExit(hMod, VLT_GET_API_FAILED, "VltGetApi");
		}

		//
		// Get the Scp Interface.
		//
		if ( 0 == ( theAuthSvr = VltGetAuth( ) ) )
		{
			CloseAndExit(hMod, VLT_GET_AUTH_FAILED, "VltGetAuth");
		}


        //---------------------------------------------------------------------
        // The Api is setup, its ok to call interface funtions
        //---------------------------------------------------------------------
        // 1: Login as the manufacturer.
        //---------------------------------------------------------------------
        if ( VLT_OK != (usActualSW = theBaseApi->VltSubmitPassword(VLT_USER7,
                VLT_MANUFACTURER,
                ucManufPasswordLength,
                (VLT_U8*)strManufPassword.c_str() ) ) )
			CloseAndExit(hMod,usActualSW,"Logging as manufacturer failed"); 

		//---------------------------------------------------------------------
        // 2: Transition to the creation  state.
        //---------------------------------------------------------------------
		//To be sure to delete all data we need to go on Activated state (if it's not the case)
		//and after to go on creation state
		theBaseApi->VltSetStatus(VLT_OPERATIONAL_ACTIVE); 
		theBaseApi->VltSetStatus(VLT_CREATION );
		
		 //---------------------------------------------------------------------
        // 3: Delete all users.
        //---------------------------------------------------------------------
		VLT_MANAGE_AUTH_DATA deleteAuthSetup;
        // Assign the manage authentication Operation IDs, more in "vaultic_consts.c" 
        deleteAuthSetup.u8OperationID = VLT_DELETE_USER;

        // Assign the first user ID.
        deleteAuthSetup.u8UserID = VLT_USER0;
            
		for (int i=VLT_USER0;i<VLT_USER7;i++) //Do not delete manufacturer
		{
			cout << "Delete User " << i << endl;
			deleteAuthSetup.u8UserID = i;
			theBaseApi->VltManageAuthenticationData( 
				&deleteAuthSetup );
		}

        //---------------------------------------------------------------------
        // 4: Create an user with password authentication method.
        //---------------------------------------------------------------------
		VLT_U8 userPin[] = {0x30, 0x31,0x30, 0x31,0x30, 0x31};

        VLT_MANAGE_AUTH_DATA structAuthSetup;
        // Assign the manage authentication Operation IDs, more in "vaultic_consts.c" 
        structAuthSetup.u8OperationID = VLT_CREATE_USER;
        // Assign the first user ID.
        structAuthSetup.u8UserID = USER_PIN_ID;
        // Utilise SCP03 authentication method (uses SCP service).
		structAuthSetup.u8Method = VLT_LOGIN_PASSWORD;
        // Make the user an approved user.
		structAuthSetup.u8RoleID = VLT_NON_APPROVED_USER;
        // Make the minimum require secure channel level the highest level possible.
        structAuthSetup.u8ChannelLevel = VLT_NO_CHANNEL;
        // Enable delete all user files if the user locks their account.
        structAuthSetup.u8SecurityOption = 0x00;
        // Assign a small try count to perevent an attack (account locked after 3 failed authentication attempts).
        structAuthSetup.u8TryCount = 3;

		// Set Password value
		memcpy(&structAuthSetup.data.cleartext.u8Password,userPin,sizeof(userPin));
		structAuthSetup.data.cleartext.u8PasswordLength = (VLT_U8)sizeof(userPin);

		 if (VLT_OK != ( usActualSW = theBaseApi->VltManageAuthenticationData( 
            &structAuthSetup ) ) )
			CloseAndExit(hMod,usActualSW,"Create user failed"); 

		 //---------------------------------------------------------------------
        // 5: Transition to the operational activated state.
        //---------------------------------------------------------------------
        if (VLT_OK != ( usActualSW = theBaseApi->VltSetStatus( 
			VLT_OPERATIONAL_ACTIVE ) ) )
			CloseAndExit(hMod,usActualSW,"Set status as operational active failed"); 

		 //---------------------------------------------------------------------
        // 6: Log the manufacturer out of the VaultIC Secure Object.
        //---------------------------------------------------------------------
        if (VLT_OK != ( usActualSW = theBaseApi->VltCancelAuthentication(  ) ) )
			CloseAndExit(hMod,usActualSW,"Logout failed"); 

		//---------------------------------------------------------------------
        // 7: Log as user.  
        //---------------------------------------------------------------------
        if ( VLT_OK != (usActualSW = theBaseApi->VltSubmitPassword(VLT_USER0,
			VLT_NON_APPROVED_USER,
                sizeof(userPin),
                (VLT_U8*)userPin ) ) )
				CloseAndExit(hMod,usActualSW,"Logging as user failed"); 

		//---------------------------------------------------------------------
        // 8: Create ECDSA P256 domain params 
        //---------------------------------------------------------------------
#define DOMAIN_PARAMS DOMAIN_B571

#if (DOMAIN_PARAMS == DOMAIN_P256)
		cout << "Use domain parameters P256"<< endl;
		//P256 Domain param data
		VLT_U8 primeQ[] = {0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}; 
		VLT_U8 xPoint[] = {0x6b, 0x17, 0xd1, 0xf2, 0xe1, 0x2c, 0x42, 0x47, 0xf8, 0xbc, 0xe6, 0xe5, 0x63, 0xa4, 0x40, 0xf2, 0x77, 0x03, 0x7d, 0x81, 0x2d, 0xeb, 0x33, 0xa0, 0xf4, 0xa1, 0x39, 0x45, 0xd8, 0x98, 0xc2, 0x96}; 
		VLT_U8 yPoint[] = {0x4f, 0xe3, 0x42, 0xe2, 0xfe, 0x1a, 0x7f, 0x9b, 0x8e, 0xe7, 0xeb, 0x4a, 0x7c, 0x0f, 0x9e, 0x16, 0x2b, 0xce, 0x33, 0x57, 0x6b, 0x31, 0x5e, 0xce, 0xcb, 0xb6, 0x40, 0x68, 0x37, 0xbf, 0x51, 0xf5}; 
		VLT_U8 zPoint[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}; 
		VLT_U8 coeffA[] = {0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc}; 
		VLT_U8 coeffB[] = {0x5a, 0xc6, 0x35, 0xd8, 0xaa, 0x3a, 0x93, 0xe7, 0xb3, 0xeb, 0xbd, 0x55, 0x76, 0x98, 0x86, 0xbc, 0x65, 0x1d, 0x06, 0xb0, 0xcc, 0x53, 0xb0, 0xf6, 0x3b, 0xce, 0x3c, 0x3e, 0x27, 0xd2, 0x60, 0x4b}; 
		VLT_U8 orderN[] = {0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51}; 
		VLT_U32 cofactorH = 0x01; 
#elif (DOMAIN_PARAMS == DOMAIN_P192)
		cout << "Use domain parameters P192"<< endl;
		//P192
		VLT_U8 primeQ[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}; 
		VLT_U8 xPoint[] = {0x18,0x8D,0xA8,0x0E,0xB0,0x30,0x90,0xF6,0x7C,0xBF,0x20,0xEB,0x43,0xA1,0x88,0x00,0xF4,0xFF,0x0A,0xFD,0x82,0xFF,0x10,0x12}; 
		VLT_U8 yPoint[] = {0x07,0x19,0x2b,0x95,0xff,0xc8,0xda,0x78,0x63,0x10,0x11,0xed,0x6b,0x24,0xcd,0xd5,0x73,0xf9,0x77,0xa1,0x1e,0x79,0x48,0x11}; 
		VLT_U8 zPoint[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 coeffA[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC}; 
		VLT_U8 coeffB[] = {0x64,0x21,0x05,0x19,0xE5,0x9C,0x80,0xE7,0x0F,0xA7,0xE9,0xAB,0x72,0x24,0x30,0x49,0xFE,0xB8,0xDE,0xEC,0xC1,0x46,0xB9,0xB1}; 
		VLT_U8 orderN[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x99,0xDE,0xF8,0x36,0x14,0x6B,0xC9,0xB1,0xB4,0xD2,0x28,0x31}; 
		VLT_U32 cofactorH = 0x01;
#elif (DOMAIN_PARAMS == DOMAIN_P224)
		cout << "Use domain parameters P224"<< endl;
		//P224
		VLT_U8 primeQ[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 xPoint[] = {0xB7,0x0E,0x0C,0xBD,0x6B,0xB4,0xBF,0x7F,0x32,0x13,0x90,0xB9,0x4A,0x03,0xC1,0xD3,0x56,0xC2,0x11,0x22,0x34,0x32,0x80,0xD6,0x11,0x5C,0x1D,0x21}; 
		VLT_U8 yPoint[] = {0xbd,0x37,0x63,0x88,0xb5,0xf7,0x23,0xfb,0x4c,0x22,0xdf,0xe6,0xcd,0x43,0x75,0xa0,0x5a,0x07,0x47,0x64,0x44,0xd5,0x81,0x99,0x85,0x00,0x7e,0x34}; 
		VLT_U8 zPoint[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 coeffA[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE}; 
		VLT_U8 coeffB[] = {0xB4,0x05,0x0A,0x85,0x0C,0x04,0xB3,0xAB,0xF5,0x41,0x32,0x56,0x50,0x44,0xB0,0xB7,0xD7,0xBF,0xD8,0xBA,0x27,0x0B,0x39,0x43,0x23,0x55,0xFF,0xB4}; 
		VLT_U8 orderN[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x16,0xA2,0xE0,0xB8,0xF0,0x3E,0x13,0xDD,0x29,0x45,0x5C,0x5C,0x2A,0x3D}; 
		VLT_U32 cofactorH = 0x01;
#elif (DOMAIN_PARAMS == DOMAIN_P384)
		cout << "Use domain parameters P384"<< endl;
		//P384
		VLT_U8 primeQ[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF}; 
		VLT_U8 xPoint[] = {0xAA,0x87,0xCA,0x22,0xBE,0x8B,0x05,0x37,0x8E,0xB1,0xC7,0x1E,0xF3,0x20,0xAD,0x74,0x6E,0x1D,0x3B,0x62,0x8B,0xA7,0x9B,0x98,0x59,0xF7,0x41,0xE0,0x82,0x54,0x2A,0x38,0x55,0x02,0xF2,0x5D,0xBF,0x55,0x29,0x6C,0x3A,0x54,0x5E,0x38,0x72,0x76,0x0A,0xB7}; 
		VLT_U8 yPoint[] = {0x36,0x17,0xde,0x4a,0x96,0x26,0x2c,0x6f,0x5d,0x9e,0x98,0xbf,0x92,0x92,0xdc,0x29,0xf8,0xf4,0x1d,0xbd,0x28,0x9a,0x14,0x7c,0xe9,0xda,0x31,0x13,0xb5,0xf0,0xb8,0xc0,0x0a,0x60,0xb1,0xce,0x1d,0x7e,0x81,0x9d,0x7a,0x43,0x1d,0x7c,0x90,0xea,0x0e,0x5f}; 
		VLT_U8 zPoint[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 coeffA[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFC}; 
		VLT_U8 coeffB[] = {0xB3,0x31,0x2F,0xA7,0xE2,0x3E,0xE7,0xE4,0x98,0x8E,0x05,0x6B,0xE3,0xF8,0x2D,0x19,0x18,0x1D,0x9C,0x6E,0xFE,0x81,0x41,0x12,0x03,0x14,0x08,0x8F,0x50,0x13,0x87,0x5A,0xC6,0x56,0x39,0x8D,0x8A,0x2E,0xD1,0x9D,0x2A,0x85,0xC8,0xED,0xD3,0xEC,0x2A,0xEF}; 
		VLT_U8 orderN[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC7,0x63,0x4D,0x81,0xF4,0x37,0x2D,0xDF,0x58,0x1A,0x0D,0xB2,0x48,0xB0,0xA7,0x7A,0xEC,0xEC,0x19,0x6A,0xCC,0xC5,0x29,0x73}; 
		VLT_U32 cofactorH = 0x01;
	  
#elif (DOMAIN_PARAMS == DOMAIN_P521)
		cout << "Use domain parameters P521"<< endl;
		//P521
		VLT_U8 primeQ[] = {0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}; 
		VLT_U8 xPoint[] = {0x00,0x00,0x00,0xC6,0x85,0x8E,0x06,0xB7,0x04,0x04,0xE9,0xCD,0x9E,0x3E,0xCB,0x66,0x23,0x95,0xB4,0x42,0x9C,0x64,0x81,0x39,0x05,0x3F,0xB5,0x21,0xF8,0x28,0xAF,0x60,0x6B,0x4D,0x3D,0xBA,0xA1,0x4B,0x5E,0x77,0xEF,0xE7,0x59,0x28,0xFE,0x1D,0xC1,0x27,0xA2,0xFF,0xA8,0xDE,0x33,0x48,0xB3,0xC1,0x85,0x6A,0x42,0x9B,0xF9,0x7E,0x7E,0x31,0xC2,0xE5,0xBD,0x66}; 
		VLT_U8 yPoint[] = {0x00,0x00,0x01,0x18,0x39,0x29,0x6a,0x78,0x9a,0x3b,0xc0,0x04,0x5c,0x8a,0x5f,0xb4,0x2c,0x7d,0x1b,0xd9,0x98,0xf5,0x44,0x49,0x57,0x9b,0x44,0x68,0x17,0xaf,0xbd,0x17,0x27,0x3e,0x66,0x2c,0x97,0xee,0x72,0x99,0x5e,0xf4,0x26,0x40,0xc5,0x50,0xb9,0x01,0x3f,0xad,0x07,0x61,0x35,0x3c,0x70,0x86,0xa2,0x72,0xc2,0x40,0x88,0xbe,0x94,0x76,0x9f,0xd1,0x66,0x50}; 
		VLT_U8 zPoint[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 coeffA[] = {0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC}; 
		VLT_U8 coeffB[] = {0x00,0x00,0x00,0x51,0x95,0x3E,0xB9,0x61,0x8E,0x1C,0x9A,0x1F,0x92,0x9A,0x21,0xA0,0xB6,0x85,0x40,0xEE,0xA2,0xDA,0x72,0x5B,0x99,0xB3,0x15,0xF3,0xB8,0xB4,0x89,0x91,0x8E,0xF1,0x09,0xE1,0x56,0x19,0x39,0x51,0xEC,0x7E,0x93,0x7B,0x16,0x52,0xC0,0xBD,0x3B,0xB1,0xBF,0x07,0x35,0x73,0xDF,0x88,0x3D,0x2C,0x34,0xF1,0xEF,0x45,0x1F,0xD4,0x6B,0x50,0x3F,0x00}; 
		VLT_U8 orderN[] = {0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFA,0x51,0x86,0x87,0x83,0xBF,0x2F,0x96,0x6B,0x7F,0xCC,0x01,0x48,0xF7,0x09,0xA5,0xD0,0x3B,0xB5,0xC9,0xB8,0x89,0x9C,0x47,0xAE,0xBB,0x6F,0xB7,0x1E,0x91,0x38,0x64,0x09}; 
		VLT_U32 cofactorH = 0x01;
#elif (DOMAIN_PARAMS == DOMAIN_B163)
		cout << "Use domain parameters B163"<< endl;
		//B163
		VLT_U8 primeQ[] = {0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC9}; 
		VLT_U8 xPoint[] = {0x00, 0x00, 0x00, 0x03, 0xF0, 0xEB, 0xA1, 0x62, 0x86, 0xA2, 0xD5, 0x7E, 0xA0, 0x99, 0x11, 0x68, 0xD4, 0x99, 0x46, 0x37, 0xE8, 0x34, 0x3E, 0x36}; 
		VLT_U8 yPoint[] = {0x00, 0x00, 0x00, 0x00, 0xD5, 0x1F, 0xBC, 0x6C, 0x71, 0xA0, 0x09, 0x4F, 0xA2, 0xCD, 0xD5, 0x45, 0xB1, 0x1C, 0x5C, 0x0C, 0x79, 0x73, 0x24, 0xF1}; 
		VLT_U8 zPoint[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}; 
		VLT_U8 coeffA[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}; 
		VLT_U8 coeffB[] = {0x00, 0x00, 0x00, 0x02, 0x0A, 0x60, 0x19, 0x07, 0xB8, 0xC9, 0x53, 0xCA, 0x14, 0x81, 0xEB, 0x10, 0x51, 0x2F, 0x78, 0x74, 0x4A, 0x32, 0x05, 0xFD}; 
		VLT_U8 orderN[] = {0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x92, 0xFE, 0x77, 0xE7, 0x0C, 0x12, 0xA4, 0x23, 0x4C, 0x33}; 
		VLT_U32 cofactorH = 0x02; 
#elif (DOMAIN_PARAMS == DOMAIN_K163)
		cout << "Use domain parameters K163"<< endl;
		//K163
		VLT_U8 primeQ[] = {0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC9}; 
		VLT_U8 xPoint[] = {0x00, 0x00, 0x00, 0x02, 0xFE, 0x13, 0xC0, 0x53, 0x7B, 0xBC, 0x11, 0xAC, 0xAA, 0x07, 0xD7, 0x93, 0xDE, 0x4E, 0x6D, 0x5E, 0x5C, 0x94, 0xEE, 0xE8}; 
		VLT_U8 yPoint[] = {0x00, 0x00, 0x00, 0x02, 0x89, 0x07, 0x0F, 0xB0, 0x5D, 0x38, 0xFF, 0x58, 0x32, 0x1F, 0x2E, 0x80, 0x05, 0x36, 0xD5, 0x38, 0xCC, 0xDA, 0xA3, 0xD9}; 
		VLT_U8 zPoint[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}; 
		VLT_U8 coeffA[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}; 
		VLT_U8 coeffB[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}; 
		VLT_U8 orderN[] = {0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x08, 0xA2, 0xE0, 0xCC, 0x0D, 0x99, 0xF8, 0xA5, 0xEF}; 
		VLT_U32 cofactorH = 0x02; 
#elif (DOMAIN_PARAMS == DOMAIN_B233)
		cout << "Use domain parameters B233"<< endl;
		//B233
		VLT_U8 primeQ[] = {0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 xPoint[] = {0x00,0x00,0x00,0xFA,0xC9,0xDF,0xCB,0xAC,0x83,0x13,0xBB,0x21,0x39,0xF1,0xBB,0x75,0x5F,0xEF,0x65,0xBC,0x39,0x1F,0x8B,0x36,0xF8,0xF8,0xEB,0x73,0x71,0xFD,0x55,0x8B}; 
		VLT_U8 yPoint[] = {0x00,0x00,0x01,0x00,0x6A,0x08,0xA4,0x19,0x03,0x35,0x06,0x78,0xE5,0x85,0x28,0xBE,0xBF,0x8A,0x0B,0xEF,0xF8,0x67,0xA7,0xCA,0x36,0x71,0x6F,0x7E,0x01,0xF8,0x10,0x52}; 
		VLT_U8 zPoint[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 coeffA[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};
		VLT_U8 coeffB[] = {0x00,0x00,0x00,0x66,0x64,0x7E,0xDE,0x6C,0x33,0x2C,0x7F,0x8C,0x09,0x23,0xBB,0x58,0x21,0x3B,0x33,0x3B,0x20,0xE9,0xCE,0x42,0x81,0xFE,0x11,0x5F,0x7D,0x8F,0x90,0xAD}; 
		VLT_U8 orderN[] = {0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x13,0xE9,0x74,0xE7,0x2F,0x8A,0x69,0x22,0x03,0x1D,0x26,0x03,0xCF,0xE0,0xD7}; 
		VLT_U32 cofactorH = 0x00000002;
#elif (DOMAIN_PARAMS == DOMAIN_K233)
		cout << "Use domain parameters K233"<< endl;
		//K233
		VLT_U8 primeQ[] = {0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 xPoint[] = {0x00,0x00,0x01,0x72,0x32,0xBA,0x85,0x3A,0x7E,0x73,0x1A,0xF1,0x29,0xF2,0x2F,0xF4,0x14,0x95,0x63,0xA4,0x19,0xC2,0x6B,0xF5,0x0A,0x4C,0x9D,0x6E,0xEF,0xAD,0x61,0x26}; 
		VLT_U8 yPoint[] = {0x00,0x00,0x01,0xDB,0x53,0x7D,0xEC,0xE8,0x19,0xB7,0xF7,0x0F,0x55,0x5A,0x67,0xC4,0x27,0xA8,0xCD,0x9B,0xF1,0x8A,0xEB,0x9B,0x56,0xE0,0xC1,0x10,0x56,0xFA,0xE6,0xA3}; 
		VLT_U8 zPoint[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 coeffA[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; 
		VLT_U8 coeffB[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 orderN[] = {0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x9D,0x5B,0xB9,0x15,0xBC,0xD4,0x6E,0xFB,0x1A,0xD5,0xF1,0x73,0xAB,0xDF}; 
		VLT_U32 cofactorH = 0x00000004; 
#elif (DOMAIN_PARAMS == DOMAIN_B283)
		cout << "Use domain parameters B283"<< endl;
		//B283
		VLT_U8 primeQ[] = {0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0xA1}; 
		VLT_U8 xPoint[] = {0x05,0xF9,0x39,0x25,0x8D,0xB7,0xDD,0x90,0xE1,0x93,0x4F,0x8C,0x70,0xB0,0xDF,0xEC,0x2E,0xED,0x25,0xB8,0x55,0x7E,0xAC,0x9C,0x80,0xE2,0xE1,0x98,0xF8,0xCD,0xBE,0xCD,0x86,0xB1,0x20,0x53}; 
		VLT_U8 yPoint[] = {0x03,0x67,0x68,0x54,0xFE,0x24,0x14,0x1C,0xB9,0x8F,0xE6,0xD4,0xB2,0x0D,0x02,0xB4,0x51,0x6F,0xF7,0x02,0x35,0x0E,0xDD,0xB0,0x82,0x67,0x79,0xC8,0x13,0xF0,0xDF,0x45,0xBE,0x81,0x12,0xF4}; 
		VLT_U8 zPoint[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 coeffA[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 coeffB[] = {0x02,0x7B,0x68,0x0A,0xC8,0xB8,0x59,0x6D,0xA5,0xA4,0xAF,0x8A,0x19,0xA0,0x30,0x3F,0xCA,0x97,0xFD,0x76,0x45,0x30,0x9F,0xA2,0xA5,0x81,0x48,0x5A,0xF6,0x26,0x3E,0x31,0x3B,0x79,0xA2,0xF5}; 
		VLT_U8 orderN[] = {0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0x90,0x39,0x96,0x60,0xFC,0x93,0x8A,0x90,0x16,0x5B,0x04,0x2A,0x7C,0xEF,0xAD,0xB3,0x07}; 
		VLT_U32 cofactorH = 0x00000002;
#elif (DOMAIN_PARAMS == DOMAIN_K283)
		cout << "Use domain parameters K283"<< endl;
		//K283
		VLT_U8 primeQ[] = {0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xA1}; 
		VLT_U8 xPoint[] = {0x05, 0x03, 0x21, 0x3F, 0x78, 0xCA, 0x44, 0x88, 0x3F, 0x1A, 0x3B, 0x81, 0x62, 0xF1, 0x88, 0xE5, 0x53, 0xCD, 0x26, 0x5F, 0x23, 0xC1, 0x56, 0x7A, 0x16, 0x87, 0x69, 0x13, 0xB0, 0xC2, 0xAC, 0x24, 0x58, 0x49, 0x28, 0x36}; 
		VLT_U8 yPoint[] = {0x01, 0xCC, 0xDA, 0x38, 0x0F, 0x1C, 0x9E, 0x31, 0x8D, 0x90, 0xF9, 0x5D, 0x07, 0xE5, 0x42, 0x6F, 0xE8, 0x7E, 0x45, 0xC0, 0xE8, 0x18, 0x46, 0x98, 0xE4, 0x59, 0x62, 0x36, 0x4E, 0x34, 0x11, 0x61, 0x77, 0xDD, 0x22, 0x59}; 
		VLT_U8 zPoint[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}; 
		VLT_U8 coeffA[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; 
		VLT_U8 coeffB[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}; 
		VLT_U8 orderN[] = {0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE9, 0xAE, 0x2E, 0xD0, 0x75, 0x77, 0x26, 0x5D, 0xFF, 0x7F, 0x94, 0x45, 0x1E, 0x06, 0x1E, 0x16, 0x3C, 0x61}; 
		VLT_U32 cofactorH = 0x00000004;
#elif (DOMAIN_PARAMS == DOMAIN_B409)
		cout << "Use domain parameters B409"<< endl;
		//B409
		VLT_U8 primeQ[] = {0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 xPoint[] = {0x01,0x5D,0x48,0x60,0xD0,0x88,0xDD,0xB3,0x49,0x6B,0x0C,0x60,0x64,0x75,0x62,0x60,0x44,0x1C,0xDE,0x4A,0xF1,0x77,0x1D,0x4D,0xB0,0x1F,0xFE,0x5B,0x34,0xE5,0x97,0x03,0xDC,0x25,0x5A,0x86,0x8A,0x11,0x80,0x51,0x56,0x03,0xAE,0xAB,0x60,0x79,0x4E,0x54,0xBB,0x79,0x96,0xA7};
		VLT_U8 yPoint[] = {0x00,0x61,0xB1,0xCF,0xAB,0x6B,0xE5,0xF3,0x2B,0xBF,0xA7,0x83,0x24,0xED,0x10,0x6A,0x76,0x36,0xB9,0xC5,0xA7,0xBD,0x19,0x8D,0x01,0x58,0xAA,0x4F,0x54,0x88,0xD0,0x8F,0x38,0x51,0x4F,0x1F,0xDF,0x4B,0x4F,0x40,0xD2,0x18,0x1B,0x36,0x81,0xC3,0x64,0xBA,0x02,0x73,0xC7,0x06}; 
		VLT_U8 zPoint[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};  
		VLT_U8 coeffA[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 coeffB[] = {0x00,0x21,0xA5,0xC2,0xC8,0xEE,0x9F,0xEB,0x5C,0x4B,0x9A,0x75,0x3B,0x7B,0x47,0x6B,0x7F,0xD6,0x42,0x2E,0xF1,0xF3,0xDD,0x67,0x47,0x61,0xFA,0x99,0xD6,0xAC,0x27,0xC8,0xA9,0xA1,0x97,0xB2,0x72,0x82,0x2F,0x6C,0xD5,0x7A,0x55,0xAA,0x4F,0x50,0xAE,0x31,0x7B,0x13,0x54,0x5F}; 
		VLT_U8 orderN[] = {0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xE2,0xAA,0xD6,0xA6,0x12,0xF3,0x33,0x07,0xBE,0x5F,0xA4,0x7C,0x3C,0x9E,0x05,0x2F,0x83,0x81,0x64,0xCD,0x37,0xD9,0xA2,0x11,0x73}; 
		VLT_U32 cofactorH = 0x00000002;
	  
#elif (DOMAIN_PARAMS == DOMAIN_K409)
		cout << "Use domain parameters K409"<< endl;
		//K409
		VLT_U8 primeQ[] = {0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 xPoint[] = {0x00,0x60,0xF0,0x5F,0x65,0x8F,0x49,0xC1,0xAD,0x3A,0xB1,0x89,0x0F,0x71,0x84,0x21,0x0E,0xFD,0x09,0x87,0xE3,0x07,0xC8,0x4C,0x27,0xAC,0xCF,0xB8,0xF9,0xF6,0x7C,0xC2,0xC4,0x60,0x18,0x9E,0xB5,0xAA,0xAA,0x62,0xEE,0x22,0x2E,0xB1,0xB3,0x55,0x40,0xCF,0xE9,0x02,0x37,0x46}; 
		VLT_U8 yPoint[] = {0x01,0xE3,0x69,0x05,0x0B,0x7C,0x4E,0x42,0xAC,0xBA,0x1D,0xAC,0xBF,0x04,0x29,0x9C,0x34,0x60,0x78,0x2F,0x91,0x8E,0xA4,0x27,0xE6,0x32,0x51,0x65,0xE9,0xEA,0x10,0xE3,0xDA,0x5F,0x6C,0x42,0xE9,0xC5,0x52,0x15,0xAA,0x9C,0xA2,0x7A,0x58,0x63,0xEC,0x48,0xD8,0xE0,0x28,0x6B}; 
		VLT_U8 zPoint[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 coeffA[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; 
		VLT_U8 coeffB[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};  
		VLT_U8 orderN[] = {0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x5F,0x83,0xB2,0xD4,0xEA,0x20,0x40,0x0E,0xC4,0x55,0x7D,0x5E,0xD3,0xE3,0xE7,0xCA,0x5B,0x4B,0x5C,0x83,0xB8,0xE0,0x1E,0x5F,0xCF}; 
		VLT_U32 cofactorH = 0x00000004;
#elif (DOMAIN_PARAMS == DOMAIN_B571)
		cout << "Use domain parameters B571"<< endl;
		//B571
		VLT_U8 primeQ[] = {0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x25}; 
		VLT_U8 xPoint[] = {0x03,0x03,0x00,0x1D,0x34,0xB8,0x56,0x29,0x6C,0x16,0xC0,0xD4,0x0D,0x3C,0xD7,0x75,0x0A,0x93,0xD1,0xD2,0x95,0x5F,0xA8,0x0A,0xA5,0xF4,0x0F,0xC8,0xDB,0x7B,0x2A,0xBD,0xBD,0xE5,0x39,0x50,0xF4,0xC0,0xD2,0x93,0xCD,0xD7,0x11,0xA3,0x5B,0x67,0xFB,0x14,0x99,0xAE,0x60,0x03,0x86,0x14,0xF1,0x39,0x4A,0xBF,0xA3,0xB4,0xC8,0x50,0xD9,0x27,0xE1,0xE7,0x76,0x9C,0x8E,0xEC,0x2D,0x19}; 
		VLT_U8 yPoint[] = {0x03,0x7B,0xF2,0x73,0x42,0xDA,0x63,0x9B,0x6D,0xCC,0xFF,0xFE,0xB7,0x3D,0x69,0xD7,0x8C,0x6C,0x27,0xA6,0x00,0x9C,0xBB,0xCA,0x19,0x80,0xF8,0x53,0x39,0x21,0xE8,0xA6,0x84,0x42,0x3E,0x43,0xBA,0xB0,0x8A,0x57,0x62,0x91,0xAF,0x8F,0x46,0x1B,0xB2,0xA8,0xB3,0x53,0x1D,0x2F,0x04,0x85,0xC1,0x9B,0x16,0xE2,0xF1,0x51,0x6E,0x23,0xDD,0x3C,0x1A,0x48,0x27,0xAF,0x1B,0x8A,0xC1,0x5B}; 
		VLT_U8 zPoint[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 coeffA[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 coeffB[] = {0x02,0xF4,0x0E,0x7E,0x22,0x21,0xF2,0x95,0xDE,0x29,0x71,0x17,0xB7,0xF3,0xD6,0x2F,0x5C,0x6A,0x97,0xFF,0xCB,0x8C,0xEF,0xF1,0xCD,0x6B,0xA8,0xCE,0x4A,0x9A,0x18,0xAD,0x84,0xFF,0xAB,0xBD,0x8E,0xFA,0x59,0x33,0x2B,0xE7,0xAD,0x67,0x56,0xA6,0x6E,0x29,0x4A,0xFD,0x18,0x5A,0x78,0xFF,0x12,0xAA,0x52,0x0E,0x4D,0xE7,0x39,0xBA,0xCA,0x0C,0x7F,0xFE,0xFF,0x7F,0x29,0x55,0x72,0x7A}; 
		VLT_U8 orderN[] = {0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE6,0x61,0xCE,0x18,0xFF,0x55,0x98,0x73,0x08,0x05,0x9B,0x18,0x68,0x23,0x85,0x1E,0xC7,0xDD,0x9C,0xA1,0x16,0x1D,0xE9,0x3D,0x51,0x74,0xD6,0x6E,0x83,0x82,0xE9,0xBB,0x2F,0xE8,0x4E,0x47}; 
		VLT_U32 cofactorH = 0x00000004;	  
#elif (DOMAIN_PARAMS == DOMAIN_K571)
		cout << "Use domain parameters K571"<< endl;
		//K571
		VLT_U8 primeQ[] = {0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x25}; 
		VLT_U8 xPoint[] = {0x02,0x6E,0xB7,0xA8,0x59,0x92,0x3F,0xBC,0x82,0x18,0x96,0x31,0xF8,0x10,0x3F,0xE4,0xAC,0x9C,0xA2,0x97,0x00,0x12,0xD5,0xD4,0x60,0x24,0x80,0x48,0x01,0x84,0x1C,0xA4,0x43,0x70,0x95,0x84,0x93,0xB2,0x05,0xE6,0x47,0xDA,0x30,0x4D,0xB4,0xCE,0xB0,0x8C,0xBB,0xD1,0xBA,0x39,0x49,0x47,0x76,0xFB,0x98,0x8B,0x47,0x17,0x4D,0xCA,0x88,0xC7,0xE2,0x94,0x52,0x83,0xA0,0x1C,0x89,0x72}; 
		VLT_U8 yPoint[] = {0x03,0x49,0xDC,0x80,0x7F,0x4F,0xBF,0x37,0x4F,0x4A,0xEA,0xDE,0x3B,0xCA,0x95,0x31,0x4D,0xD5,0x8C,0xEC,0x9F,0x30,0x7A,0x54,0xFF,0xC6,0x1E,0xFC,0x00,0x6D,0x8A,0x2C,0x9D,0x49,0x79,0xC0,0xAC,0x44,0xAE,0xA7,0x4F,0xBE,0xBB,0xB9,0xF7,0x72,0xAE,0xDC,0xB6,0x20,0xB0,0x1A,0x7B,0xA7,0xAF,0x1B,0x32,0x04,0x30,0xC8,0x59,0x19,0x84,0xF6,0x01,0xCD,0x4C,0x14,0x3E,0xF1,0xC7,0xA3}; 
		VLT_U8 zPoint[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 coeffA[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; 
		VLT_U8 coeffB[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01}; 
		VLT_U8 orderN[] = {0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x13,0x18,0x50,0xE1,0xF1,0x9A,0x63,0xE4,0xB3,0x91,0xA8,0xDB,0x91,0x7F,0x41,0x38,0xB6,0x30,0xD8,0x4B,0xE5,0xD6,0x39,0x38,0x1E,0x91,0xDE,0xB4,0x5C,0xFE,0x77,0x8F,0x63,0x7C,0x10,0x01}; 
		VLT_U32 cofactorH = 0x00000004;
#endif
		
		VLT_KEY_OBJECT domainParams;
		domainParams.u8KeyID = VLT_KEY_ECDSA_DOMAIN_PARMS;

		domainParams.data.EcdsaParamsKey.u8Assurance	= 0x00;
		domainParams.data.EcdsaParamsKey.u16QLen		= sizeof(primeQ);
		domainParams.data.EcdsaParamsKey.u16NLen		= sizeof(orderN);
		domainParams.data.EcdsaParamsKey.u32H			= cofactorH;
		domainParams.data.EcdsaParamsKey.pu8Q			= (VLT_PU8)malloc(domainParams.data.EcdsaParamsKey.u16QLen);
		domainParams.data.EcdsaParamsKey.pu8Gx			= (VLT_PU8)malloc(domainParams.data.EcdsaParamsKey.u16QLen);
		domainParams.data.EcdsaParamsKey.pu8Gy			= (VLT_PU8)malloc(domainParams.data.EcdsaParamsKey.u16QLen);
		domainParams.data.EcdsaParamsKey.pu8Gz			= (VLT_PU8)malloc(domainParams.data.EcdsaParamsKey.u16QLen);
		domainParams.data.EcdsaParamsKey.pu8A			= (VLT_PU8)malloc(domainParams.data.EcdsaParamsKey.u16QLen);
		domainParams.data.EcdsaParamsKey.pu8B			= (VLT_PU8)malloc(domainParams.data.EcdsaParamsKey.u16QLen);

		domainParams.data.EcdsaParamsKey.pu8N			= (VLT_PU8)malloc(domainParams.data.EcdsaParamsKey.u16NLen);

		if ((domainParams.data.EcdsaParamsKey.pu8Q == NULL)
			|| (domainParams.data.EcdsaParamsKey.pu8Gx == NULL)
			|| (domainParams.data.EcdsaParamsKey.pu8Gy == NULL)
			|| (domainParams.data.EcdsaParamsKey.pu8Gz == NULL)
			|| (domainParams.data.EcdsaParamsKey.pu8A == NULL)
			|| (domainParams.data.EcdsaParamsKey.pu8B == NULL)
			|| (domainParams.data.EcdsaParamsKey.pu8N == NULL))
		{
			FREE(domainParams.data.EcdsaParamsKey.pu8Q);
			FREE(domainParams.data.EcdsaParamsKey.pu8Gx);
			FREE(domainParams.data.EcdsaParamsKey.pu8Gy);
			FREE(domainParams.data.EcdsaParamsKey.pu8Gz);
			FREE(domainParams.data.EcdsaParamsKey.pu8A );
			FREE(domainParams.data.EcdsaParamsKey.pu8B );
			FREE(domainParams.data.EcdsaParamsKey.pu8N );
		}

		memcpy(domainParams.data.EcdsaParamsKey.pu8Q,primeQ,domainParams.data.EcdsaParamsKey.u16QLen);
		memcpy(domainParams.data.EcdsaParamsKey.pu8Gx,xPoint,domainParams.data.EcdsaParamsKey.u16QLen);
		memcpy(domainParams.data.EcdsaParamsKey.pu8Gy,yPoint,domainParams.data.EcdsaParamsKey.u16QLen);
		memcpy(domainParams.data.EcdsaParamsKey.pu8Gz,zPoint,domainParams.data.EcdsaParamsKey.u16QLen);
		memcpy(domainParams.data.EcdsaParamsKey.pu8A,coeffA,domainParams.data.EcdsaParamsKey.u16QLen);
		memcpy(domainParams.data.EcdsaParamsKey.pu8B,coeffB,domainParams.data.EcdsaParamsKey.u16QLen);
		memcpy(domainParams.data.EcdsaParamsKey.pu8N,orderN,domainParams.data.EcdsaParamsKey.u16NLen);

		VLT_FILE_PRIVILEGES domainParamsAccess;
		domainParamsAccess.u8Read		= 0xFF;
		domainParamsAccess.u8Write		= (1 << USER_PIN_ID);
		domainParamsAccess.u8Delete		= (1 << USER_PIN_ID);
		domainParamsAccess.u8Execute	= (1 << USER_PIN_ID);

		VLT_U8 domainKeyGroup = 0x10;
		VLT_U8 domainKeyIndex = 0x25;
		cout << "Put ECC domain parameters key"<< endl;
		usActualSW = theBaseApi->VltPutKey(domainKeyGroup,domainKeyIndex,&domainParamsAccess,&domainParams);

		FREE(domainParams.data.EcdsaParamsKey.pu8Q);
		FREE(domainParams.data.EcdsaParamsKey.pu8Gx);
		FREE(domainParams.data.EcdsaParamsKey.pu8Gy);
		FREE(domainParams.data.EcdsaParamsKey.pu8Gz);
		FREE(domainParams.data.EcdsaParamsKey.pu8A );
		FREE(domainParams.data.EcdsaParamsKey.pu8B );
		FREE(domainParams.data.EcdsaParamsKey.pu8N );
		
		if (VLT_OK != usActualSW)
			CloseAndExit(hMod,usActualSW,"Put ECC domain parameters key failed"); 
	
		//---------------------------------------------------------------------
        // 9: Import or generate an ECDH P256 key pair 
        //---------------------------------------------------------------------
		VLT_FILE_PRIVILEGES pubAccess;
		pubAccess.u8Read		= 0xFF;
		pubAccess.u8Execute		= (1 << USER_PIN_ID);
		pubAccess.u8Write		= (1 << USER_PIN_ID);
		pubAccess.u8Delete		= (1 << USER_PIN_ID);

		VLT_FILE_PRIVILEGES privAccess;
		privAccess.u8Read		= (1 << USER_PIN_ID);
		privAccess.u8Execute	= (1 << USER_PIN_ID);
		privAccess.u8Write		= (1 << USER_PIN_ID);
		privAccess.u8Delete		= (1 << USER_PIN_ID);

		VLT_U8 pubKeyGroup = 0x30;
		VLT_U8 pubKeyIndex = 0x01;
		VLT_U8 privStaticKeyGroup = 0x31;
		VLT_U8 privStaticKeyIndex = 0x01;

#ifdef IMPORT_KEY
		VLT_U8 pX[] = {0x67, 0x32, 0x05, 0x98, 0x48, 0x11, 0x75, 0x58, 0x8e, 0x43, 0xb5, 0x2d, 0x5a, 0xca, 0xcd, 0x4a, 0xc1, 0x2d, 0xfc, 0x17, 0x61, 0x8f, 0x1d, 0xc5, 0x40, 0x92, 0x50, 0x1b, 0xa7, 0x28, 0x53, 0x09}; 
		VLT_U8 pY[] = {0xde, 0x30, 0xfb, 0xf4, 0x96, 0x6a, 0xb8, 0xe3, 0xcc, 0x89, 0x71, 0x7a, 0xb3, 0xbf, 0xfc, 0xf9, 0x8f, 0xd1, 0x86, 0x4a, 0x62, 0x80, 0xc6, 0x69, 0x78, 0xd2, 0xeb, 0x4f, 0xb6, 0xa4, 0x86, 0x51}; 
		VLT_U8 pD[] = {0x7a, 0x87, 0x57, 0x96, 0x74, 0x0f, 0x5e, 0x92, 0x86, 0x97, 0x26, 0xcd, 0xe2, 0x1c, 0x64, 0x8a, 0xc5, 0x8a, 0x1f, 0x33, 0x11, 0xad, 0xdb, 0x81, 0x49, 0xa1, 0xf9, 0xcc, 0xf3, 0x80, 0xf9, 0x25}; 
		
		VLT_KEY_OBJECT ecdhPubKeyObj;
		ecdhPubKeyObj.u8KeyID = VLT_KEY_ECC_PUB;
		ecdhPubKeyObj.data.EcdsaPubKey.u16QLen			= 0x20;
		ecdhPubKeyObj.data.EcdsaPubKey.pu8Qx				= (VLT_PU8)malloc(ecdhPubKeyObj.data.EcdsaPubKey.u16QLen);
		ecdhPubKeyObj.data.EcdsaPubKey.pu8Qy				= (VLT_PU8)malloc(ecdhPubKeyObj.data.EcdsaPubKey.u16QLen);
		memcpy(ecdhPubKeyObj.data.EcdsaPubKey.pu8Qx,pX,ecdhPubKeyObj.data.EcdsaPubKey.u16QLen);
		memcpy(ecdhPubKeyObj.data.EcdsaPubKey.pu8Qy,pY,ecdhPubKeyObj.data.EcdsaPubKey.u16QLen);
		ecdhPubKeyObj.data.EcdsaPubKey.u8DomainParamsGroup = domainKeyGroup;
		ecdhPubKeyObj.data.EcdsaPubKey.u8DomainParamsIndex = domainKeyIndex;

		VLT_KEY_OBJECT ecdhPrivKeyObj;
		ecdhPrivKeyObj.u8KeyID = VLT_KEY_ECC_PRIV;
		ecdhPrivKeyObj.data.EcdsaPrivKey.u8Mask			= 0x00;
		ecdhPrivKeyObj.data.EcdsaPrivKey.u16DLen			= 0x20; 
		ecdhPrivKeyObj.data.EcdsaPrivKey.pu8D			= (VLT_PU8)malloc(ecdhPrivKeyObj.data.EcdsaPrivKey.u16DLen);
		memcpy(ecdhPrivKeyObj.data.EcdsaPrivKey.pu8D,pD,ecdhPrivKeyObj.data.EcdsaPrivKey.u16DLen);
		ecdhPrivKeyObj.data.EcdsaPrivKey.u8DomainParamsGroup = domainKeyGroup;
		ecdhPrivKeyObj.data.EcdsaPrivKey.u8DomainParamsIndex = domainKeyIndex;
		ecdhPrivKeyObj.data.EcdsaPrivKey.u8PublicKeyGroup = pubKeyGroup;
		ecdhPrivKeyObj.data.EcdsaPrivKey.u8PublicKeyIndex = pubKeyIndex;

		cout << "Import an ECDH P256 key pair "<< endl;
		cout << "Put public ECDH P256 key"<< endl;
		usActualSW = theBaseApi->VltPutKey(pubKeyGroup,pubKeyIndex,&pubAccess,&ecdhPubKeyObj);
		if ( VLT_OK == usActualSW )
		{
			cout << "Put private ECDH P256 key"<< endl;
			usActualSW = theBaseApi->VltPutKey(privStaticKeyGroup,privStaticKeyIndex,&privAccess,&ecdhPrivKeyObj);
			 if ( VLT_OK != usActualSW)
			 {
				 theBaseApi->VltDeleteKey(pubKeyGroup,pubKeyIndex);
			 }
		}
		FREE(ecdhPubKeyObj.data.EcdhPubKey.pu8Qx);
		FREE(ecdhPubKeyObj.data.EcdhPubKey.pu8Qy);
		FREE(ecdhPrivKeyObj.data.EcdhPrivKey.pu8D);

		if ( VLT_OK != usActualSW)
			CloseAndExit(hMod,usActualSW,"Put ECDH keypair key failed");
#else
		VLT_KEY_GEN_DATA keygenData;
#if (DOMAIN_PARAMS == DOMAIN_P192 || DOMAIN_PARAMS == DOMAIN_P224 ||DOMAIN_PARAMS == DOMAIN_P256 ||DOMAIN_PARAMS == DOMAIN_P384 ||DOMAIN_PARAMS == DOMAIN_P521)
		keygenData.u8AlgoID = VLT_ALG_KPG_ECDSA_GFP;
#else
		keygenData.u8AlgoID = VLT_ALG_KPG_ECDSA_GF2M;
#endif
		keygenData.data.EcdsaDsaKeyGenObj.u8DomainParamsGroup = domainKeyGroup;
		keygenData.data.EcdsaDsaKeyGenObj.u8DomainParamsIndex = domainKeyIndex;
		cout << "Generate an ECC key pair "<< endl;
		usActualSW = theBaseApi->VltGenerateKeyPair(pubKeyGroup,pubKeyIndex,&pubAccess,privStaticKeyGroup,privStaticKeyIndex,&privAccess,&keygenData);

		if ( VLT_OK != usActualSW)
			CloseAndExit(hMod,usActualSW,"Generate ECC keypair key failed");
#endif
		//---------------------------------------------------------------------
        // 10: Read ECDH public key 
        //---------------------------------------------------------------------
		VLT_KEY_OBJECT pubKeyObj;
		pubKeyObj.u8KeyID = VLT_KEY_ECC_PUB;
		pubKeyObj.data.EcdsaPubKey.u16QLen = 0x50;
		pubKeyObj.data.EcdsaPubKey.pu8Qx = (VLT_PU8)malloc(pubKeyObj.data.EcdsaPubKey.u16QLen);
		pubKeyObj.data.EcdsaPubKey.pu8Qy = (VLT_PU8)malloc(pubKeyObj.data.EcdsaPubKey.u16QLen);
		cout << "Read ECDH public key"<< endl;
		if ( VLT_OK != (usActualSW = theBaseApi->VltReadKey(pubKeyGroup,pubKeyIndex,&pubKeyObj)))
			CloseAndExit(hMod,usActualSW,"Read ECDH public key failed");

		//---------------------------------------------------------------------
        // 11: Construct DH agreement 
        //---------------------------------------------------------------------

		//Construct One pass 
		VLT_KEY_MATERIAL keyMaterial;

	
#if (DOMAIN_PARAMS == DOMAIN_P192 || DOMAIN_PARAMS == DOMAIN_P224 ||DOMAIN_PARAMS == DOMAIN_P256 ||DOMAIN_PARAMS == DOMAIN_P384 ||DOMAIN_PARAMS == DOMAIN_P521)
		keyMaterial.u8AlgoID = VLT_ALG_KAS_ONEPASS_BSI_ECC_DH_GFp;
#else
		keyMaterial.u8AlgoID = VLT_ALG_KAS_ONEPASS_BSI_ECC_DH_GF2m;
#endif
		keyMaterial.u8StaticKeyGroup = (VLT_U8)privStaticKeyGroup;
		keyMaterial.u8StaticKeyIndex = (VLT_U8)privStaticKeyIndex;
	
		/* */
		keyMaterial.data.onePass.u8KLen = 0x05 + (2 * pubKeyObj.data.EcdsaPubKey.u16QLen);
		keyMaterial.data.onePass.pu8keyObject = (VLT_PU8)malloc(keyMaterial.data.onePass.u8KLen);

		VLT_U16 idxObject = 0;
		keyMaterial.data.onePass.pu8keyObject[idxObject++] = VLT_KEY_ECC_PUB;
		keyMaterial.data.onePass.pu8keyObject[idxObject++] = (VLT_U8) ((pubKeyObj.data.EcdsaPubKey.u16QLen >> 8) & 0xFF);
		keyMaterial.data.onePass.pu8keyObject[idxObject++] = (VLT_U8) ((pubKeyObj.data.EcdsaPubKey.u16QLen >> 0) & 0xFF);
		memcpy(&keyMaterial.data.onePass.pu8keyObject[idxObject],pubKeyObj.data.EcdsaPubKey.pu8Qx,pubKeyObj.data.EcdsaPubKey.u16QLen);
		idxObject+= pubKeyObj.data.EcdsaPubKey.u16QLen;
		memcpy(&keyMaterial.data.onePass.pu8keyObject[idxObject],pubKeyObj.data.EcdsaPubKey.pu8Qy,pubKeyObj.data.EcdsaPubKey.u16QLen);
		idxObject+= pubKeyObj.data.EcdsaPubKey.u16QLen;

		keyMaterial.data.onePass.pu8keyObject[idxObject++] = pubKeyObj.data.EcdsaPubKey.u8DomainParamsGroup;
		keyMaterial.data.onePass.pu8keyObject[idxObject++] = pubKeyObj.data.EcdsaPubKey.u8DomainParamsIndex;

		VLT_U8 DHAgreementGroup = 0xFF;
		VLT_U8 DHAgreementIndex = 0x00;

		VLT_FILE_PRIVILEGES DHAgreementAccess;
		DHAgreementAccess.u8Read		= (1 << USER_PIN_ID);
		DHAgreementAccess.u8Execute		= (1 << USER_PIN_ID);
		DHAgreementAccess.u8Write		= (1 << USER_PIN_ID);
		DHAgreementAccess.u8Delete		= (1 << USER_PIN_ID);

		if ( VLT_OK != (usActualSW = theBaseApi->VltConstructDHAgreement(DHAgreementGroup,DHAgreementIndex,&DHAgreementAccess,&keyMaterial) ) )
			CloseAndExit(hMod,usActualSW,"Construct DH agreement failed");

		//---------------------------------------------------------------------
        // 12: Read DH Agreement key 
        //---------------------------------------------------------------------
		VLT_KEY_OBJECT dhKeyObj;
		dhKeyObj.u8KeyID = VLT_KEY_SECRET_VALUE;
		dhKeyObj.data.SecretKey.u16KeyLength = 0x50;
		dhKeyObj.data.SecretKey.pu8Key = (VLT_PU8)malloc(dhKeyObj.data.SecretKey.u16KeyLength);
		dhKeyObj.data.SecretKey.u8Mask = 0x00;
		cout << "Read DH Agreement key"<< endl;
		usActualSW = theBaseApi->VltReadKey(DHAgreementGroup,DHAgreementIndex,&dhKeyObj);

		FREE(dhKeyObj.data.SecretKey.pu8Key);

		if ( VLT_OK != usActualSW)
			CloseAndExit(hMod,usActualSW,"Read DH Agreement key failed");

		//---------------------------------------------------------------------
        // 13: Derive key 
        //---------------------------------------------------------------------
		VLT_U8 derivedKeyGroup = 0x40;
		VLT_U8 derivedKeyIndex = 0x01;
		VLT_FILE_PRIVILEGES derivedKeyAccess;
		derivedKeyAccess.u8Read		= 0xFF;
		derivedKeyAccess.u8Execute	= 0xFF;
		derivedKeyAccess.u8Write	= 0xFF;
		derivedKeyAccess.u8Delete	= 0xFF;
		VLT_U16 derivatedKeyLength	= 0x20*8;

		VLT_KEY_DERIVATION keyDerivation;
		keyDerivation.u8AlgoID = VLT_ALG_KDF_HASH_MODE;
		keyDerivation.data.hashMode.u8digest = VLT_ALG_DIG_SHA256;
		keyDerivation.data.hashMode.u16appendLen = 0;
		keyDerivation.data.hashMode.u16prependLen = 0;
		keyDerivation.u8SecretKeyGroup = DHAgreementGroup;
		keyDerivation.u8SecretKeyIndex = DHAgreementIndex;

		if ( VLT_OK != (usActualSW = theBaseApi->VltDeriveKey(derivedKeyGroup,derivedKeyIndex,&derivedKeyAccess,VLT_KEY_AES_256,derivatedKeyLength, &keyDerivation)) )
			CloseAndExit(hMod,usActualSW,"Construct Derive key failed");

        //---------------------------------------------------------------------
        // 14: Log back in as the manufacturer.  
        //---------------------------------------------------------------------
        if ( VLT_OK != (usActualSW = theBaseApi->VltSubmitPassword(VLT_USER7,
                VLT_MANUFACTURER,
                ucManufPasswordLength,
                (VLT_U8*)strManufPassword.c_str() ) ) )
			CloseAndExit(hMod,usActualSW,"Log as manufacturer failed");

        //---------------------------------------------------------------------
        // 15: Transition to the operational deactive state.
        //---------------------------------------------------------------------
        if (VLT_OK != ( usActualSW = theBaseApi->VltSetStatus( 
            VLT_OPERATIONAL_DEACTIVE ) ) )
			CloseAndExit(hMod,usActualSW,"Set status as OPERATIONAL DEACTIVE failed");

        //---------------------------------------------------------------------
        // 16: Log back in as the manufacturer.  
        //---------------------------------------------------------------------
        if ( VLT_OK != (usActualSW = theBaseApi->VltSubmitPassword(VLT_USER7,
                VLT_MANUFACTURER,
                ucManufPasswordLength,
                (VLT_U8*)strManufPassword.c_str() ) ) )
			CloseAndExit(hMod,usActualSW,"Log as manufacturer failed");

        //---------------------------------------------------------------------
        // 17: Transition to the creation state, wipes the file system.
        //---------------------------------------------------------------------
        if (VLT_OK != ( usActualSW = theBaseApi->VltSetStatus( 
            VLT_CREATION ) ) )
			CloseAndExit(hMod,usActualSW,"Set status as CREATION failed");

        //---------------------------------------------------------------------
        // 18: Log back in as the manufacturer, to delete user 0.  
        //---------------------------------------------------------------------
        if ( VLT_OK != (usActualSW = theBaseApi->VltSubmitPassword(VLT_USER7,
                VLT_MANUFACTURER,
                ucManufPasswordLength,
                (VLT_U8*)strManufPassword.c_str() ) ) )
			CloseAndExit(hMod,usActualSW,"Log as manufacturer failed");

        //---------------------------------------------------------------------
        // 19: Delete user 0, which should leave the VaultIC in a virgin state.
        //---------------------------------------------------------------------
        structAuthSetup.u8OperationID = VLT_DELETE_USER;
        // Assign the first user ID.
        structAuthSetup.u8UserID = VLT_USER0;
                
        if (VLT_OK != ( usActualSW = theBaseApi->VltManageAuthenticationData( 
            &structAuthSetup ) ) )
			CloseAndExit(hMod,usActualSW,"Delete user failed");

        //---------------------------------------------------------------------
        // 20: Log the manufacturer out of the VaultIC Secure Object.
        //---------------------------------------------------------------------
        if (VLT_OK != ( usActualSW = theBaseApi->VltCancelAuthentication(  ) ) )
			CloseAndExit(hMod,usActualSW,"Logout failed");
                
		CloseAndExit(hMod,0,"Example code complete, VaultIC file system wiped and users deleted (not manufacturer).");
    }
	catch(...)
	{
		CloseAndExit(hMod,0,"Unknown Exception caught.");
    }
}


bool DisplayBuffer(const unsigned long& ulCipherTextSize,
                   const unsigned char* pucBuffer)
{
    const unsigned char ucLineLength = 8;

    if ( 0 == pucBuffer )
    {
        return false;
    }
    
    unsigned long ulRoundedNumberOfChars = ( ulCipherTextSize + 
        ( ulCipherTextSize % ucLineLength ) );

    for ( unsigned int i = 0; i < ulRoundedNumberOfChars; i++ )
    {
        for ( unsigned int j = 0; j < ucLineLength; j++, i++ )
        {
            if ( i >= ulCipherTextSize )
            {
                break;
            }
            // print each character
            cout << "0x" << hex << setw(2) << setfill('0') 
                << static_cast<int>( pucBuffer[i] ) << " ";
        }
        // new line
        cout << endl;
    }
    
    return true;
}