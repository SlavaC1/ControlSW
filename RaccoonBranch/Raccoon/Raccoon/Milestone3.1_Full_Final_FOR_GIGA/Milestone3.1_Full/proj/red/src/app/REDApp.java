import token.classes.Crypto;
import token.classes.Except;
import token.classes.Sys;

// Exception Table
//
//   101 - Current challenge/random is not equal to last tag verification
//   102 - Tag is invalid
//   103 - Invalid certificate length
//   104 - Tag was not found
//   105 - Invalid signature length
//   107 - Random array should be pre-allocated
//   108 - Tag's pubKC is wrong
//   109 - No free tag structure
//   110 - Invalid tagNo
//   111 - SignedWeight length is wrong
//   112 - newWeight is not tagWeight - tagConsumption
//   113 - newWeight is 0, cartridge is empty

public class REDApp {
  // Flag to switch between debug and release build
  final static boolean isDebug = false;

  /////////////////////////////////////////////////////////////////////////////
  // Constants
  /////////////////////////////////////////////////////////////////////////////

  // Stratasys Demo ECDSA K-283 Public Key
  private final static byte[] PubKS = new byte[] {
    //////////
    // Original Statasys Public Key as shared by Shlomit
    (byte)0x05, (byte)0x9f, (byte)0x2b, (byte)0x26, (byte)0x5e, (byte)0xa4, (byte)0xbc, (byte)0x30,
    (byte)0x81, (byte)0x2c, (byte)0x34, (byte)0x3d, (byte)0x26, (byte)0x3f, (byte)0xe3, (byte)0xea,
    (byte)0x22, (byte)0x57, (byte)0x9d, (byte)0x99, (byte)0x1e, (byte)0xef, (byte)0x25, (byte)0x7f,
    (byte)0xab, (byte)0xea, (byte)0xfb, (byte)0xeb, (byte)0x83, (byte)0xf0, (byte)0xf2, (byte)0x56,
    (byte)0xf1, (byte)0xc9, (byte)0x3c, (byte)0x36,
    (byte)0x00, (byte)0x24, (byte)0x09, (byte)0x30, (byte)0xbd, (byte)0x1e, (byte)0x5d, (byte)0xe7,
    (byte)0xde, (byte)0x32, (byte)0xfd, (byte)0x56, (byte)0xae, (byte)0xff, (byte)0xb8, (byte)0x08,
    (byte)0x2f, (byte)0x86, (byte)0xc7, (byte)0x71, (byte)0x3c, (byte)0x40, (byte)0x8e, (byte)0x27,
    (byte)0x21, (byte)0x24, (byte)0xba, (byte)0x6e, (byte)0x89, (byte)0x43, (byte)0xc1, (byte)0xb9,
    (byte)0x28, (byte)0xeb, (byte)0x0e, (byte)0xb5
    //////////
    //////////
    // Demo Public Key (from the demo key pair used in the RED-Demo)
    //(byte)0x03, (byte)0xD8, (byte)0x06, (byte)0x77, (byte)0x45, (byte)0xC6, (byte)0xD2, (byte)0xE7,
    //(byte)0x18, (byte)0xB7, (byte)0xF8, (byte)0xCF, (byte)0x07, (byte)0x0E, (byte)0x51, (byte)0xD5,
    //(byte)0x87, (byte)0x99, (byte)0x13, (byte)0xFA, (byte)0x2F, (byte)0x33, (byte)0x6C, (byte)0xD4,
    //(byte)0xB0, (byte)0xB4, (byte)0x05, (byte)0x3A, (byte)0x47, (byte)0x97, (byte)0x7E, (byte)0x08,
    //(byte)0xDD, (byte)0x40, (byte)0xEB, (byte)0x92,
    //(byte)0x05, (byte)0x95, (byte)0x3C, (byte)0x78, (byte)0x3C, (byte)0x07, (byte)0xBF, (byte)0xE9,
    //(byte)0x75, (byte)0xC5, (byte)0x2D, (byte)0x59, (byte)0x81, (byte)0xCA, (byte)0xCD, (byte)0x2B,
    //(byte)0xC6, (byte)0x8A, (byte)0xE3, (byte)0xF0, (byte)0xB8, (byte)0x65, (byte)0xEC, (byte)0x00,
    //(byte)0x9F, (byte)0x1F, (byte)0x79, (byte)0x95, (byte)0xE4, (byte)0xA6, (byte)0xED, (byte)0xB7,
    //(byte)0x4B, (byte)0x02, (byte)0x67, (byte)0x41
    //////////
  };

  // The value indicates invalid tag number
  private final static byte InvalidTagNo = 127;

  //The length of tag info
  private final static byte TagInfoLen = 35;

  // The length of all public keys
  private final static byte PubKlen = 72;

  // The length of all signatures generated by the chip
  private final static byte SIGlen = 72;

  // The length of all random values used by the software
  private final static byte RNDlen = 8;

  // The size of the weight value (4 byte integer)
  private final static byte WeightLen = 4;

  // Certificate
  //   |message is TagInfo and pubKC (PubKlen bytes)
  //   |signatureLen (2 bytes little endian)
  //   |signature (SIGlen bytes)|
  private final static short CertLen = TagInfoLen + PubKlen + 2 + SIGlen;

  // The cartridge public key location within the certificate
  // Note: This points to the beginning of the message, starting with pubKC
  private final static short PubKCoffset = TagInfoLen;

  // The signature location within the certificate
  // Note: This points to signatureLen, not to signature
  private final static short CertSIGoffset = TagInfoLen + PubKlen;

  // SignedWeight
  //   |message is Weight Data - 28 bytes
  //   |signatureLen (2 bytes little endian)
  //   |signature (SIGlen bytes)|
  private final static short SignedWeightLen = 102;

  // The signature location within the signed weight
  // Note: This points to signatureLen, not so signature
  private final static short WeightSIGoffset = 28;

  // The random value location within the signed weight
  // Note: This points to RED random
  private final static short WeightRNDoffset = 16;

  // The weight location within the signed weight
  private final static short WeightOffset = 24;

  // Number of Active Tags cached in dongle RAM
  private final static byte ActiveTagsLen = 8;

  // Min value for tagNo
  private final static byte TagNoMin = 0;

  // Max value for tagNo
  private final static byte TagNoMax = 15;

  private final static short signedChallengeLen = 106;

  private final static short challengeOffset = 8;

  private final static short signedChallengeMessgeLen = 32;

  private final static short signedChallengeSignatureOffset = signedChallengeMessgeLen + 2;

  /////////////////////////////////////////////////////////////////////////////
  // Global Variables
  /////////////////////////////////////////////////////////////////////////////

  // Active Tags start with index 1; extra tag (not active) is at index 0
  // private static Tag[] tags = new Tag[1 + ActiveTagsLen];
  private static Tag[] tags = new Tag[] { new Tag(), new Tag(), new Tag(), new Tag(), new Tag(), new Tag(), new Tag(), new Tag(), new Tag() };

  // Indicates that the entire procedure works correctly (not bypassed)
  private static boolean isValid = true; // initialized to true value

  // The last random string generated by the dongle
  private static byte[] tagRandom = new byte[RNDlen];

  // The tagNo/isActive which was used when creating the tagRandom
  private static byte lastTagNo = TagNoMax + 1; // initialize to invalid
  private static boolean lastIsActive;

  // Slices counter (this is only used by Application Placeholder functions)
  private static byte Slices = 0;

  /////////////////////////////////////////////////////////////////////////////
  // Helper Variables
  /////////////////////////////////////////////////////////////////////////////

  // Message; extracted from signedWeight only
  private static byte[] message = new byte[WeightSIGoffset];

  // Signature extracted from certificate or signedWeight
  private static byte[] signature = new byte[SIGlen];

  /////////////////////////////////////////////////////////////////////////////
  // Helper Subclasses
  /////////////////////////////////////////////////////////////////////////////
  public static class Tag {
    Tag() {
    }

    // Tag number, valid range is 0-15, InvalidTagNo (127) marks an entry to be free
    byte tagNo = InvalidTagNo;

    //Info retrieved from input (not in use)
    byte[] tagInfo = new byte[TagInfoLen];

    // Tag public key
    byte[] pubKC = new byte[PubKlen];

    // Updated cartridge weight
    int tagWeight;

    // Recent consumption to be debited
    int tagConsumption;

    // Indicates that the tag is genuine and the cartridge is not empty
    boolean isTagValid;
  }

  /////////////////////////////////////////////////////////////////////////////
  // REDApp ctor, init function
  /////////////////////////////////////////////////////////////////////////////

  public REDApp() {
  }

  /////////////////////////////////////////////////////////////////////////////
  // Low-Level Services
  /////////////////////////////////////////////////////////////////////////////

  private static boolean verifyMessage(byte[] publicKey, byte[] message, byte[] signature) {
    byte[] msg = new byte[32];

    Crypto.sha256Init();
    Crypto.sha256Update(message);
    Crypto.sha256Finish(msg);

    return Crypto.k283VerifyMessage(msg, signature, publicKey) == 0;
  }

  private static void generateRandom(byte[] random) {
    Crypto.rand();
    Crypto.genRandom(random, 0, random.length);
  }

  /////////////////////////////////////////////////////////////////////////////
  // API Methods
  /////////////////////////////////////////////////////////////////////////////
  public static boolean verifyTag(byte tagNo, boolean isActive, byte[] certificate, byte[] random) {
    // Check range of tagNo
    if (tagNo < TagNoMin || tagNo > TagNoMax) {
      if (isDebug) throw Except.genException(110, "Invalid tagNo");
      return false;
    }

    // Check certificate length
    if (certificate == null || certificate.length != CertLen) {
      if (isDebug) throw Except.genException(103, "Invalid certificate length");
      return false;
    }

    // Check random length
    if (random == null || random.length != tagRandom.length) {
      if (isDebug) throw Except.genException(107, "Random array should be pre-allocated");
      return false;
    }

    // Check if this active tag already exists
    byte tagIndex = getTagIndex(tagNo, isActive);
    if (tagIndex > 0) {
      // The certificate should contain the same pubKC like the tag
      if (!Sys.memCmp(tags[tagIndex].pubKC, 0, certificate, PubKCoffset, PubKlen)) {
        if (isDebug) throw Except.genException(108, "Tag's pubKC is wrong");
        return false;
      }
    }

    // At this point tagIndex can be invalid (-1), or point to extra tag (0)
    // Check if we need to find a free active tag structure
    if (tagIndex < 0) {
      // We need to find a free tag structure
      tagIndex = getTagIndex(InvalidTagNo, true);

      // Fail, when we cannot find a free tag structure
      if (tagIndex < 0) {
        if (isDebug) throw Except.genException(109, "No free tag structure");
        return false;
      }
    }

    // We are pedantic pessimists, let's assume it fails
    tags[tagIndex].isTagValid = false;

    // messageLen is CertSIGoffset
    // message is the first messageLen bytes
    // ... it is the same like the pubKC from the certificate
    // ... copy the tag public key from the certificate, using PubKCoffset and PubKlen
    Sys.memCpy(tags[tagIndex].pubKC, 0, certificate, PubKCoffset, PubKlen);

    // signatureLen is a short value that starts at certificate + CertSIGoffset
    short signatureLen = (short)((certificate[CertSIGoffset + 1] & 0xFF) << 8 |
                                 (certificate[CertSIGoffset + 0] & 0xFF));

    // ... and should be equal to SIGlen
    if (signatureLen != SIGlen) {
      if (isDebug) throw Except.genException(105, "Invalid signature length");
      return false;
    }

    // signature is SIGlen bytes that starts at certificate + CertSIGoffset + 2
    Sys.memCpy(signature, 0, certificate, CertSIGoffset + 2, SIGlen);

///////////////////////////////////////
// Verification of test vector (for challenge) shared by Shlomit
//
//byte[] testvector_message = new byte[] {
//  (byte)0xeb, (byte)0x6f, (byte)0x0a, (byte)0x87, (byte)0xcd, (byte)0x13, (byte)0x3a, (byte)0x12,
//  (byte)0xc4, (byte)0x66, (byte)0x3a, (byte)0x61, (byte)0xbc, (byte)0xfe, (byte)0x84, (byte)0x17,
//  (byte)0x53, (byte)0x74, (byte)0x72, (byte)0x61, (byte)0x74, (byte)0x61, (byte)0x73, (byte)0x79,
//  (byte)0x73, (byte)0x50, (byte)0x72, (byte)0x69, (byte)0x6e, (byte)0x74, (byte)0x65, (byte)0x72
//};
//
//byte[] testvector_digest = new byte[32];
//
//byte[] testvector_device_pubkey = new byte[] {
// (byte)0x00, (byte)0x56, (byte)0x6c, (byte)0xfd, (byte)0x48, (byte)0x5e, (byte)0xc1, (byte)0xd0,
// (byte)0xc3, (byte)0x91, (byte)0x75, (byte)0x5b, (byte)0xcc, (byte)0x64, (byte)0xdd, (byte)0x7b,
// (byte)0xf7, (byte)0x59, (byte)0x2d, (byte)0x19, (byte)0xa9, (byte)0xaa, (byte)0x8d, (byte)0xf7,
// (byte)0x74, (byte)0x3a, (byte)0xdb, (byte)0xd0, (byte)0x18, (byte)0x79, (byte)0x29, (byte)0xec,
// (byte)0x34, (byte)0xf1, (byte)0x31, (byte)0xd6, (byte)0x01, (byte)0x10, (byte)0x84, (byte)0xd7,
// (byte)0xe1, (byte)0x6b, (byte)0xc4, (byte)0x4d, (byte)0x59, (byte)0x8b, (byte)0xc5, (byte)0x33,
// (byte)0xc7, (byte)0xb3, (byte)0x84, (byte)0x6d, (byte)0x3a, (byte)0x34, (byte)0x25, (byte)0x83,
// (byte)0xe2, (byte)0x28, (byte)0xc9, (byte)0x8c, (byte)0x75, (byte)0xa3, (byte)0xc3, (byte)0x3d,
// (byte)0x09, (byte)0x45, (byte)0x49, (byte)0x0a, (byte)0x00, (byte)0x57, (byte)0x46, (byte)0x1a
//};
//
//byte[] testvector_signature = new byte[]{
// (byte)0x00, (byte)0x2f, (byte)0xac, (byte)0x25, (byte)0x3a, (byte)0xb1, (byte)0xdf, (byte)0x5e,
// (byte)0xd3, (byte)0x35, (byte)0xb1, (byte)0x19, (byte)0x9a, (byte)0x4e, (byte)0x68, (byte)0x0d,
// (byte)0xe2, (byte)0x77, (byte)0x64, (byte)0xe1, (byte)0x52, (byte)0xab, (byte)0x88, (byte)0x89,
// (byte)0x07, (byte)0xcc, (byte)0x00, (byte)0xe9, (byte)0xfa, (byte)0x7c, (byte)0x86, (byte)0xbe,
// (byte)0xed, (byte)0x20, (byte)0x42, (byte)0xef, (byte)0x01, (byte)0x22, (byte)0x0c, (byte)0x42,
// (byte)0xe5, (byte)0x12, (byte)0x5e, (byte)0x10, (byte)0x3b, (byte)0x21, (byte)0x9c, (byte)0x11,
// (byte)0xb6, (byte)0xa9, (byte)0xcf, (byte)0xe4, (byte)0x8a, (byte)0x51, (byte)0x35, (byte)0x97,
// (byte)0x8b, (byte)0xb4, (byte)0x31, (byte)0x9d, (byte)0x4b, (byte)0xcd, (byte)0x35, (byte)0xe1,
// (byte)0xdb, (byte)0xd2, (byte)0x3c, (byte)0xad, (byte)0x71, (byte)0x70, (byte)0xd4, (byte)0x7a
//};
//
//    Crypto.sha256Init();
//    Crypto.sha256Update(testvector_message);
//    Crypto.sha256Finish(testvector_digest);
//
//if (1==1) return Crypto.k283VerifyMessage(testvector_digest, testvector_signature, testvector_device_pubkey) == 0;
////////////////////////////////////////

    // Verify the message
    byte[] message = new byte[TagInfoLen + PubKlen];
    Sys.memCpy(message, 0, certificate, 0, TagInfoLen + PubKlen);
    // If the verification fails, set isTagValid to false and return false
    if (!verifyMessage(PubKS, message, signature)) {
      //if (isDebug) throw Except.genException(114, "Verify Message failed");
      // ... isTagValid is already false (we assumed we will fail)
      return false;
    }

    // If the tag certificate is verified, initialize the tag entry
    // Our tagIndex can refer to an active tag or the extra tag
    tags[tagIndex].tagNo = tagNo;

    // Set tagWeight to -1
    tags[tagIndex].tagWeight = -1;

    // Set tagConsumption to 0
    tags[tagIndex].tagConsumption = 0;

    // Call the generateRandom() function for a random string of RNDlen bytes
    // and update the tagRandom
    generateRandom(tagRandom);

    // And return the tagRandom in the output parameter
    Sys.memCpy(random, 0, tagRandom, 0, RNDlen);

    // Remember which tag was used when creating the random
    lastTagNo = tagNo;
    lastIsActive = isActive;

    // Set the isTagValid to true
    tags[tagIndex].isTagValid = true;

    return true;
  }

  public static boolean verifyChallenge(byte tagNo, boolean isActive, byte[] signedChallenge ) {
    // Check range of tagNo
    if (tagNo < TagNoMin || tagNo > TagNoMax) {
      if (isDebug) throw Except.genException(110, "Invalid tagNo");
      return false;
    }

    // Check signature length
    if (signedChallenge.length != signedChallengeLen) {
      if (isDebug) throw Except.genException(105, "Invalid Signed Challenge length");
      return false;
    }

    // Get tagIndex
    byte tagIndex = getTagIndex(tagNo, isActive);
    if (tagIndex < 0) {
      // Tag was not found
      if (isDebug) throw Except.genException(104, "Tag was not found");
      return false;
    }

    // Check that the tag is valid
    if (tags[tagIndex].isTagValid == false) {
      if (isDebug) throw Except.genException(102, "Tag is invalid");
      return false;
    }

    // Verify that the challenge (last tagRandom) was created for the tag
    if (tagNo != lastTagNo || isActive != lastIsActive) {
      if (isDebug) throw Except.genException(101, "Current challenge/random is not equal to last tag verification");
      return false;
    }

    // Verify that the challenge (last tagRandom) is the same as the challenge in the current input.
    if (!Sys.memCmp(tagRandom, 0, signedChallenge, challengeOffset, RNDlen))
    {
      if (isDebug) throw Except.genException(101, "Current challenge/random is not equal to last challenge/random");
      return false;
    }

    byte message[] = new byte[signedChallengeMessgeLen];
    Sys.memCpy(message, 0, signedChallenge, 0, signedChallengeMessgeLen);
    Sys.memCpy(signature, 0, signedChallenge, signedChallengeSignatureOffset, SIGlen);

    if (!verifyMessage(tags[tagIndex].pubKC, message, signature)) {
      //if (isDebug) throw Except.genException(114, "Verify Message failed");
      return false;
    }

    return true;
  }

  public static boolean removeTag(byte tagNo) {
    // Check range of tagNo
    if (tagNo < TagNoMin || tagNo > TagNoMax) {
      if (isDebug) throw Except.genException(110, "Invalid tagNo");
      return false;
    }

    // Get tagIndex
    byte tagIndex = getTagIndex(tagNo, true);

    if (tagIndex < 0) {
      // Tag was not found
      if (isDebug) throw Except.genException(104, "Tag was not found");
      return false;
    }

    // Deactivate/delete the tag
    tags[tagIndex].isTagValid = false;
    tags[tagIndex].tagNo = InvalidTagNo;

    return true;
  }

  public static boolean updateConsumption(byte tagNo, boolean isActive, int consumption, byte[] random) {
    // Check range of tagNo
    if (tagNo < TagNoMin || tagNo > TagNoMax) {
      if (isDebug) throw Except.genException(110, "Invalid tagNo");
      return false;
    }

    // Check random length
    if (random == null || random.length != tagRandom.length) {
      if (isDebug) throw Except.genException(107, "Random array should be pre-allocated");
      return false;
    }

    // Get tagIndex
    byte tagIndex = getTagIndex(tagNo, isActive);
    if (tagIndex < 0) {
      // Tag was not found
      if (isDebug) throw Except.genException(104, "Tag was not found");
      return false;
    }

    // Check that the tag is valid
    if (tags[tagIndex].isTagValid == false) {
      if (isDebug) throw Except.genException(102, "Tag is invalid");
      return false;
    }

    // Update the tagConsumption
    tags[tagIndex].tagConsumption = consumption;

    // Call the generateRandom function for a new random value of RNDlen bytes
    // and update the tagRandom
    generateRandom(tagRandom);

    // And return the tagRandom in the output parameter
    Sys.memCpy(random, 0, tagRandom, 0, RNDlen);

    // Remember which tag was used when creating the random
    lastTagNo = tagNo;
    lastIsActive = isActive;

    return true;
  }

  public static boolean verifyWeight(byte tagNo, boolean isActive, byte[] signedWeight) {
    // Check range of tagNo
    if (tagNo < TagNoMin || tagNo > TagNoMax) {
      if (isDebug) throw Except.genException(110, "Invalid tagNo");
      return false;
    }

    // Check length of signedWeight
    if (signedWeight == null || signedWeight.length != SignedWeightLen) {
      if (isDebug) throw Except.genException(111, "SignedWeight length is wrong");
      return false;
    }

    // Get tagIndex
    byte tagIndex = getTagIndex(tagNo, isActive);
    if (tagIndex < 0) {
      // Tag was not found
      if (isDebug) throw Except.genException(104, "Tag was not found");
      return false;
    }

    // Check that the tag is valid
    if (tags[tagIndex].isTagValid == false) {
      if (isDebug) throw Except.genException(102, "Tag is invalid");
      return false;
    }

    // We are pedantic pessimists, let's assume it fails
    tags[tagIndex].isTagValid = false;

    // message len is WeightSIGoffset
    Sys.memCpy(message, 0, signedWeight, 0, WeightSIGoffset);

    // signatureLen is a short value that starts at signedWeight + WeightSIGoffset
    short signatureLen = (short)((signedWeight[WeightSIGoffset + 1] & 0xFF) << 8 |
                                 (signedWeight[WeightSIGoffset + 0] & 0xFF));

    // ... and should be equal to SIGlen
    if (signatureLen != SIGlen) {
      if (isDebug) throw Except.genException(105, "Invalid signature length");
      return false;
    }

    // signature is SIGlen bytes that starts at signedWeight + WeightSIGoffset + 2
    Sys.memCpy(signature, 0, signedWeight, WeightSIGoffset + 2, SIGlen);

    // Verify the message
    // If the verification fails, set isTagValid to false and return false
    if (!verifyMessage(tags[tagIndex].pubKC, message, signature)) {
      // ... isTagValid is already false (we assumed we will fail)
      return false;
    }

    // If the signedWeight was verified, the function shall:

    // Compare the random value (RNDlen bytes) located in the signedWeight
    // at WeightRNDoffset with the last generated random value
    if (!Sys.memCmp(tagRandom, 0, signedWeight, WeightRNDoffset, tagRandom.length)) {
      // ... isTagValid is already false (we assumed we will fail)
      return false;
    }

    // Our tagIndex can refer to an active tag or the extra tag

    // Isolate the newWeight from the signedWeight at WeightOffset (4 bytes integer)
    int newWeight = (signedWeight[WeightOffset + 3] << 24) |
                    (signedWeight[WeightOffset + 2] & 0xFF) << 16 |
                    (signedWeight[WeightOffset + 1] & 0xFF) << 8 |
                    (signedWeight[WeightOffset + 0] & 0xFF);

    // If the tagWeight != -1, verify that the newWeight == tagWeight - tagConsumption
    if (tags[tagIndex].tagWeight != -1) {
      if (newWeight != tags[tagIndex].tagWeight - tags[tagIndex].tagConsumption) {
        // ... isTagValid is already false (we assumed we will fail)
        if (isDebug) throw Except.genException(112, "newWeight is not tagWeight - tagConsumption");
        return false;
      }
    }

    // Update the tagWeight with the newWeight
    tags[tagIndex].tagWeight = newWeight;

    // Zero the tagConsumption
    tags[tagIndex].tagConsumption = 0;

    // If the newWeight is 0, set the isTagValid flag to false
    if (newWeight == 0) {
      // ... isTagValid is already false (we assumed we will fail)
      if (isDebug) throw Except.genException(113, "newWeight is 0, cartridge is empty");
      return false;
    }

    // Set the isTagValid to true
    tags[tagIndex].isTagValid = true;

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////
  // Application Placeholders
  /////////////////////////////////////////////////////////////////////////////
  public static int CNOF(int SW, int SR, int LHO1200, int SRX, int IEF) {
    int result = 100;

    if (!isValid) {
      return result * 2;
    }

    Slices++;

    if (Slices > 25) {
      isValid = false;
    }

    for (byte i = 1; i < tags.length; i++) {
      if (!tags[i].isTagValid) {
        return result * 3;
      }
    }

    return result;
  }

  public static int CEOP(int SOP, int SW, int SR, int LHO1200, int AF, int IEF) {
    int result = 200;

    if (!isValid) {
      return result * 2;
    }

    for (byte i = 1; i < tags.length; i++) {
      if (!tags[i].isTagValid) {
        return result * 3;
      }
    }

    return result;
  }

  public static int CNOP(int SH, int SST, int SYO, int HPW, int SPEO, int CH) {
    int result = 300;

    if (!isValid) {
      return result * 2;
    }

    for (byte i = 1; i < tags.length; i++) {
      if (!tags[i].isTagValid) {
        return result * 3;
      }
    }

    return result;
  }

  public static int CYSO(int SH, int SST, int SYO, int HPW, int NGIP, int NOP, int SPEO, int YINOP, int YSINOP) {
      int result = 400;

      if (!isValid) {
        return result * 2;
      }

      for (byte i = 1; i < tags.length; i++) {
        if (!tags[i].isTagValid) {
          return result * 3;
        }
      }

      return result;
    }

  /////////////////////////////////////////////////////////////////////////////
  // Helper Methods
  /////////////////////////////////////////////////////////////////////////////
  private static byte getTagIndex(byte tagNo, boolean isActive) {
    if (!isActive) {
      // We ignore the tagNo and use the extra tag (not active, index 0)
      return 0;
    }

    for (byte i = 1; i < tags.length; i++) {
      if (tags[i].tagNo == tagNo) {
        return i;
      }
    }

    return -1;
  }

}
