import token.classes.Except;
import token.classes.Sys;

// Exception Table
//
//   101 - Current challenge/random is not equal to last tag verification
//   102 - Tag is invalid
//   103 - Invalid certificate length
//   104 - Tag was not found
//   105 - Invalid signature length
//   107 - Random array should be pre-allocated
//   108 - Tag's pubKC is wrong
//   109 - No free tag structure
//   110 - Invalid tagNo
//   111 - SignedWeight length is wrong
//   112 - newWeight is not tagWeight - tagConsumption
//   113 - newWeight is 0, cartridge is empty

public class REDApp {
  // Flag to switch between debug and release build
  final static boolean isDebug = false;

  /////////////////////////////////////////////////////////////////////////////
  // Constants
  /////////////////////////////////////////////////////////////////////////////

  // Stratasys ECDSA K-283 Public Key
  private final static byte[] PubKS = new byte[] {
    (byte)0xAA, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47
  };

  // The value indicates invalid tag number
  private final static byte InvalidTagNo = 127;

  // The length of all public keys
  private final static byte PubKlen = 72;

  // The length of all signatures generated by the chip
  private final static byte SIGlen = 72;

  // The length of all random values used by the software
  private final static byte RNDlen = 8;

  // The size of the weight value (4 byte integer)
  private final static byte WeightLen = 4;

  // Certificate
  //   |message is pubKC (PubKlen bytes)
  //   |signatureLen (2 bytes little endian)
  //   |signature (SIGlen bytes)|
  private final static short CertLen = PubKlen + 2 + SIGlen;

  // The cartridge public key location within the certificate
  // Note: This points to the beginning of the message, starting with pubKC
  private final static short PubKCoffset = 0;

  // The signature location within the certificate
  // Note: This points to signatureLen, not to signature
  private final static short CertSIGoffset = PubKlen;

  // SignedWeight
  //   |message is newWeight (WeightLen bytes) and tagRandom (RNDlen bytes)
  //   |signatureLen (2 bytes little endian)
  //   |signature (SIGlen bytes)|
  private final static short SignedWeightLen = WeightLen + RNDlen + 2 + SIGlen;

  // The signature location within the signed weight
  // Note: This points to signatureLen, not so signature
  private final static short WeightSIGoffset = WeightLen + RNDlen;

  // The random value location within the signed weight
  // Note: This points to tagRandom
  private final static short WeightRNDoffset = WeightLen;

  // The weight location within the signed weight
  // Note: This points to the beginning of the message, starting with newWeight
  private final static short WeightOffset = 0;

  // Number of Active Tags cached in dongle RAM
  private final static byte ActiveTagsLen = 8;

  // Min value for tagNo
  private final static byte tagNoMin = 0;

  // Max value for tagNo
  private final static byte tagNoMax = 15;

  /////////////////////////////////////////////////////////////////////////////
  // Global Variables
  /////////////////////////////////////////////////////////////////////////////

  // Active Tags start with index 1; extra tag (not active) is at index 0
  // private static Tag[] tags = new Tag[1 + ActiveTagsLen];
  private static Tag[] tags = new Tag[] { new Tag(), new Tag(), new Tag(), new Tag(), new Tag(), new Tag(), new Tag(), new Tag(), new Tag() };

  // Indicates that the entire procedure works correctly (not bypassed)
  private static boolean isValid = true; // initialized to true value

  // The last random string generated by the dongle
  private static byte[] tagRandom = new byte[RNDlen];

  // The tagNo/isActive which was used when creating the tagRandom
  private static byte lastTagNo = tagNoMax + 1; // initialize to invalid
  private static boolean lastIsActive;

  // Slices counter (this is only used by Application Placeholder functions)
  private static byte Slices = 0;

  /////////////////////////////////////////////////////////////////////////////
  // Helper Variables
  /////////////////////////////////////////////////////////////////////////////

  // Message; extracted from signedWeight only
  private static byte[] message = new byte[WeightSIGoffset];

  // Signature extracted from certificate or signedWeight
  private static byte[] signature = new byte[SIGlen];

  /////////////////////////////////////////////////////////////////////////////
  // Helper Subclasses
  /////////////////////////////////////////////////////////////////////////////
  public static class Tag {
    Tag() {
    }

    // Tag number, valid range is 0-15, InvalidTagNo (127) marks an entry to be free
    byte tagNo = InvalidTagNo;

    // Tag public key
    byte[] pubKC = new byte[PubKlen];

    // Updated cartridge weight
    int tagWeight;

    // Recent consumption to be debited
    int tagConsumption;

    // Indicates that the tag is genuine and the cartridge is not empty
    boolean isTagValid;
  }

  /////////////////////////////////////////////////////////////////////////////
  // REDApp ctor, init function
  /////////////////////////////////////////////////////////////////////////////

  public REDApp() {
  }

  /////////////////////////////////////////////////////////////////////////////
  // Low-Level Services
  /////////////////////////////////////////////////////////////////////////////

  // TODO: will wrap firmware crypto verifyMessage in the second milestone
  private static boolean verifyMessage(byte[] publicKey, byte[] message, byte[] signature) {
    // mock functionality (first milestone) - third byte of signature must to be 11 to pass verification
    if (signature[2] == 11) {
      return true;
    }

    return false;
  }

  // TODO: will wrap firmware crypto generateRandom in the second milestone
  private static void generateRandom(byte[] random) {
    // mock functionality (first milestone) - random bytes will always be asterisk (42)
    Sys.memSet(random, 0, random.length, (byte)42);
  }

  /////////////////////////////////////////////////////////////////////////////
  // API Methods
  /////////////////////////////////////////////////////////////////////////////
  public static boolean verifyTag(byte tagNo, boolean isActive, byte[] certificate, byte[] random) {
    // Check range of tagNo
    if (tagNo < tagNoMin || tagNo > tagNoMax) {
      if (isDebug) Except.genException(110, "");
      return false;
    }

    // Check certificate length
    if (certificate == null || certificate.length != CertLen) {
      if (isDebug) Except.genException(103, "");
      return false;
    }

    // Check random length
    if (random == null || random.length != tagRandom.length) {
      if (isDebug) Except.genException(107, "");
      return false;
    }

    // Check if this active tag already exists
    byte tagIndex = getTagIndex(tagNo, isActive);
    if (tagIndex > 0) {
      // The certificate should contain the same pubKC like the tag
      if (!Sys.memCmp(tags[tagIndex].pubKC, 0, certificate, PubKCoffset, PubKlen)) {
        if (isDebug) Except.genException(108, "");
        return false;
      }
    }

    // At this point tagIndex can be invalid (-1), or point to extra tag (0)
    // Check if we need to find a free active tag structure
    if (tagIndex < 0) {
      // We need to find a free tag structure
      tagIndex = getTagIndex(InvalidTagNo, true);

      // Fail, when we cannot find a free tag structure
      if (tagIndex < 0) {
        if (isDebug) Except.genException(109, "");
        return false;
      }
    }

    // We are pedantic pessimists, let's assume it fails
    tags[tagIndex].isTagValid = false;

    // messageLen is CertSIGoffset
    // message is the first messageLen bytes
    // ... it is the same like the pubKC from the certificate
    // ... copy the tag public key from the certificate, using PubKCoffset and PubKlen
    Sys.memCpy(tags[tagIndex].pubKC, 0, certificate, PubKCoffset, PubKlen);

    // signatureLen is a short value that starts at certificate + CertSIGoffset
    short signatureLen = (short)((certificate[CertSIGoffset + 1] & 0xFF) << 8 |
                                 (certificate[CertSIGoffset + 0] & 0xFF));

    // ... and should be equal to SIGlen
    if (signatureLen != SIGlen) {
      if (isDebug) Except.genException(105, "");
      return false;
    }

    // signature is SIGlen bytes that starts at certificate + CertSIGoffset + 2
    Sys.memCpy(signature, 0, certificate, CertSIGoffset + 2, SIGlen);

    // Verify the message
    // If the verification fails, set isTagValid to false and return false
    if (!verifyMessage(PubKS, tags[tagIndex].pubKC, signature)) {
      // ... isTagValid is already false (we assumed we will fail)
      return false;
    }

    // If the tag certificate is verified, initialize the tag entry
    // Our tagIndex can refer to an active tag or the extra tag
    tags[tagIndex].tagNo = tagNo;

    // Set tagWeight to -1
    tags[tagIndex].tagWeight = -1;

    // Set tagConsumption to 0
    tags[tagIndex].tagConsumption = 0;

    // Call the generateRandom() function for a random string of RNDlen bytes
    // and update the tagRandom
    generateRandom(tagRandom);

    // And return the tagRandom in the output parameter
    Sys.memCpy(random, 0, tagRandom, 0, RNDlen);

    // Remember which tag was used when creating the random
    lastTagNo = tagNo;
    lastIsActive = isActive;

    // Set the isTagValid to true
    tags[tagIndex].isTagValid = true;

    return true;
  }

  public static boolean verifyChallenge(byte tagNo, boolean isActive, byte[] signature) {
    // Check range of tagNo
    if (tagNo < tagNoMin || tagNo > tagNoMax) {
      if (isDebug) Except.genException(110, "");
      return false;
    }

    // Check signature length
    if (signature.length != SIGlen) {
      if (isDebug) Except.genException(105, "");
      return false;
    }

    // Get tagIndex
    byte tagIndex = getTagIndex(tagNo, isActive);
    if (tagIndex < 0) {
      // Tag was not found
      if (isDebug) Except.genException(104, "");
      return false;
    }

//    // Check that the tag is valid
//    if (tags[tagIndex].isTagValid == false) {
//      if (isDebug) Except.genException(102, "");
//      return false;
//    }

    // Verify that the challenge (last tagRandom) was created for the tag
    if (tagNo != lastTagNo || isActive != lastIsActive) {
      if (isDebug) Except.genException(101, "");
      return false;
    }

    return verifyMessage(tags[tagIndex].pubKC, tagRandom, signature);
  }

  public static boolean removeTag(byte tagNo) {
    // Check range of tagNo
    if (tagNo < tagNoMin || tagNo > tagNoMax) {
      if (isDebug) Except.genException(110, "");
      return false;
    }

    // Get tagIndex
    byte tagIndex = getTagIndex(tagNo, true);

    if (tagIndex < 0) {
      // Tag was not found
      if (isDebug) Except.genException(104, "");
      return false;
    }

    // Deactivate/delete the tag
    tags[tagIndex].isTagValid = false;
    tags[tagIndex].tagNo = InvalidTagNo;

    return true;
  }

  public static boolean updateConsumption(byte tagNo, boolean isActive, int consumption, byte[] random) {
    // Check range of tagNo
    if (tagNo < tagNoMin || tagNo > tagNoMax) {
      if (isDebug) Except.genException(110, "");
      return false;
    }

    // Check random length
    if (random == null || random.length != tagRandom.length) {
      if (isDebug) Except.genException(107, "");
      return false;
    }

    // Get tagIndex
    byte tagIndex = getTagIndex(tagNo, isActive);
    if (tagIndex < 0) {
      // Tag was not found
      if (isDebug) Except.genException(104, "");
      return false;
    }

//    // Check that the tag is valid
//    if (tags[tagIndex].isTagValid == false) {
//      if (isDebug) Except.genException(102, "");
//      return false;
//    }

    // Update the tagConsumption
    tags[tagIndex].tagConsumption = consumption;

    // Call the generateRandom function for a new random value of RNDlen bytes
    // and update the tagRandom
    generateRandom(tagRandom);

    // And return the tagRandom in the output parameter
    Sys.memCpy(random, 0, tagRandom, 0, RNDlen);

    // Remember which tag was used when creating the random
    lastTagNo = tagNo;
    lastIsActive = isActive;

    return true;
  }

  public static boolean verifyWeight(byte tagNo, boolean isActive, byte[] signedWeight) {
    // Check range of tagNo
    if (tagNo < tagNoMin || tagNo > tagNoMax) {
      if (isDebug) Except.genException(110, "");
      return false;
    }

    // Check length of signedWeight
    if (signedWeight == null || signedWeight.length != SignedWeightLen) {
      if (isDebug) Except.genException(111, "");
      return false;
    }

    // Get tagIndex
    byte tagIndex = getTagIndex(tagNo, isActive);
    if (tagIndex < 0) {
      // Tag was not found
      if (isDebug) Except.genException(104, "");
      return false;
    }

//    // Check that the tag is valid
//    if (tags[tagIndex].isTagValid == false) {
//      if (isDebug) Except.genException(102, "");
//      return false;
//    }

    // We are pedantic pessimists, let's assume it fails
    tags[tagIndex].isTagValid = false;

    // messageLen is WeightSIGoffset
    // message is the first messageLen bytes
    Sys.memCpy(message, 0, signedWeight, 0, WeightSIGoffset);

    // signatureLen is a short value that starts at signedWeight + WeightSIGoffset
    short signatureLen = (short)((signedWeight[WeightSIGoffset + 1] & 0xFF) << 8 |
                                 (signedWeight[WeightSIGoffset + 0] & 0xFF));

    // ... and should be equal to SIGlen
    if (signatureLen != SIGlen) {
      if (isDebug) Except.genException(105, "");
      return false;
    }

    // signature is SIGlen bytes that starts at signedWeight + WeightSIGoffset + 2
    Sys.memCpy(signature, 0, signedWeight, WeightSIGoffset + 2, SIGlen);

    // Verify the message
    // If the verification fails, set isTagValid to false and return false
    if (!verifyMessage(PubKS, message, signature)) {
      // ... isTagValid is already false (we assumed we will fail)
      return false;
    }

    // If the signedWeight was verified, the function shall:

    // Compare the random value (RNDlen bytes) located in the signedWeight
    // at WeightRNDoffset with the last generated random value
    if (!Sys.memCmp(tagRandom, 0, signedWeight, WeightRNDoffset, tagRandom.length)) {
      // ... isTagValid is already false (we assumed we will fail)
      return false;
    }

    // Our tagIndex can refer to an active tag or the extra tag

    // Isolate the newWeight from the signedWeight at WeightOffset (4 bytes integer)
    int newWeight = (signedWeight[WeightOffset + 3] << 24) |
                    (signedWeight[WeightOffset + 2] & 0xFF) << 16 |
                    (signedWeight[WeightOffset + 1] & 0xFF) << 8 |
                    (signedWeight[WeightOffset + 0] & 0xFF);


    // If the tagWeight != -1, verify that the newWeight == tagWeight - tagConsumption
    if (tags[tagIndex].tagWeight != -1) {
      if (newWeight != tags[tagIndex].tagWeight - tags[tagIndex].tagConsumption) {
        // ... isTagValid is already false (we assumed we will fail)
        if (isDebug) Except.genException(112, "");
        return false;
      }
    }

    // Update the tagWeight with the newWeight
    tags[tagIndex].tagWeight = newWeight;

    // Zero the tagConsumption
    tags[tagIndex].tagConsumption = 0;

    // If the newWeight is 0, set the isTagValid flag to false
    if (newWeight == 0) {
      // ... isTagValid is already false (we assumed we will fail)
      if (isDebug) Except.genException(113, "");
      return false;
    }

    // Set the isTagValid to true
    tags[tagIndex].isTagValid = true;

    return true;
  }

  /////////////////////////////////////////////////////////////////////////////
  // Application Placeholders
  /////////////////////////////////////////////////////////////////////////////
  public static int CNOF(int SW, int SR, int LHO1200, int SRX, int IEF) {
    int result = 100;

    if (!isValid) {
      return result * 2;
    }

    Slices++;

    if (Slices > 25) {
      isValid = false;
    }

    for (byte i = 1; i < tags.length; i++) {
      if (!tags[i].isTagValid) {
        return result * 3;
      }
    }

    return result;
  }

  public static int CEOP(int SOP, int SW, int SR, int LHO1200, int AF, int IEF) {
    int result = 200;

    if (!isValid) {
      return result * 2;
    }

    for (byte i = 1; i < tags.length; i++) {
      if (!tags[i].isTagValid) {
        return result * 3;
      }
    }

    return result;
  }

  public static int CNOP(int SH, int SST, int SYO, int HPW, int SPEO, int CH) {
    int result = 300;

    if (!isValid) {
      return result * 2;
    }

    for (byte i = 1; i < tags.length; i++) {
      if (!tags[i].isTagValid) {
        return result * 3;
      }
    }

    return result;
  }

  public static int CYSO(int SH, int SST, int SYO, int HPW, int NGIP, int NOP, int SPEO, int YINOP, int YSINOP) {
    int result = 400;

    if (!isValid) {
      return result * 2;
    }

    for (byte i = 1; i < tags.length; i++) {
      if (!tags[i].isTagValid) {
        return result * 3;
      }
    }

    return result;
  }

  /////////////////////////////////////////////////////////////////////////////
  // Helper Methods
  /////////////////////////////////////////////////////////////////////////////
  private static byte getTagIndex(byte tagNo, boolean isActive) {
    if (!isActive) {
      // We ignore the tagNo and use the extra tag (not active, index 0)
      return 0;
    }

    for (byte i = 1; i < tags.length; i++) {
      if (tags[i].tagNo == tagNo) {
        return i;
      }
    }

    return -1;
  }

}
